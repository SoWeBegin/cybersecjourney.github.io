Analysis of malware 2.1  – SHA256: 6ba2fb387dae83da4316cf44ad041851763f9b5e2647ef27a6820c0cf54f8f0b

(Conclusions at the end of the document)

# Assumptions / Notes found with DIE (Detect It Easy)
- 1.1 DiE detects a packer heuristically. The packer is not known 
- 1.2 DiE also detects Anti-debugging
- 1.3 Environment: .NET, VB.NET → managed executable → CLR (Common Language Runtime) [confirmed in Static Analysis]
- Architecture: x32
  
Following assumption 1.3, we will use .NET specific decompilers & debuggers. 

# Static analysis with ILSpy & Dynamic analysis with DnSpy
At first glance through DnSpy and ILSpy, the malware doesn’t seem packed. In fact we find that the entry point is “SponsorState.KeyValuePairs.Main”:
```csharp
[EditorBrowsable(EditorBrowsableState.Advanced)]
[DebuggerHidden]
[STAThread]
[MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]
internal static void Main(string[] Args) {
  try {         
         Application.SetCompatibleTextRenderingDefault(WindowsFormsApplicationBase.UseCompatibleTextRendering);
  }
  finally {
  }
       fAnonymousType0.DebuggerStepperBoundaryAttribute.Application.Run(Args);
}
```

We can already see that [DebuggerHidden] is used, which can make it harder to debug the malware (for example breakpoints inside the Main method will be ignored). I’ll check later whether this can simply be removed through DnSpy.

The “Run” method is probably relevant so I’ll analyze that next.
#### Code 1
```csharp
[SecuritySafeCritical]
[MethodImpl(MethodImplOptions.NoInlining)]
public void Run(string[] commandLine) {
  base.InternalCommandLine = new ReadOnlyCollection < string > (commandLine);
  if (!this.IsSingleInstance) {
    this.DoApplicationModel();
    return;
  }
  string applicationInstanceID = this.GetApplicationInstanceID(Assembly.GetCallingAssembly());
  this.m_MemoryMappedID = applicationInstanceID + "Map";
  string name = applicationInstanceID + "Event";
  string text = applicationInstanceID + "Event2";
  this.m_StartNextInstanceCallback = new SendOrPostCallback(this.OnStartupNextInstanceMarshallingAdaptor);
  new SecurityPermission(SecurityPermissionFlag.ControlPrincipal).Assert();
  string name2 = WindowsIdentity.GetCurrent().Name;
  bool flag = Operators.CompareString(name2, "", false) != 0;
  CodeAccessPermission.RevertAssert();
  bool flag2;
  if (flag) {
    EventWaitHandleAccessRule rule = new EventWaitHandleAccessRule(name2, EventWaitHandleRights.FullControl, AccessControlType.Allow);
    EventWaitHandleSecurity eventWaitHandleSecurity = new EventWaitHandleSecurity();
    new SecurityPermission(SecurityPermissionFlag.ControlPrincipal).Assert();
    eventWaitHandleSecurity.AddAccessRule(rule);
    CodeAccessPermission.RevertAssert();
    this.m_FirstInstanceSemaphore = new EventWaitHandle(false, EventResetMode.ManualReset, name, ref flag2, eventWaitHandleSecurity);
    bool initialState = false;
    EventResetMode mode = EventResetMode.AutoReset;
    string name3 = text;
    bool flag3 = false;
    this.m_MessageRecievedSemaphore = new EventWaitHandle(initialState, mode, name3, ref flag3, eventWaitHandleSecurity);
  } else {
    this.m_FirstInstanceSemaphore = new EventWaitHandle(false, EventResetMode.ManualReset, name, ref flag2);
    this.m_MessageRecievedSemaphore = new EventWaitHandle(false, EventResetMode.AutoReset, text);
  }
  if (flag2) {
    try {
      TcpServerChannel tcpServerChannel = (TcpServerChannel) this.RegisterChannel(WindowsFormsApplicationBase.ChannelType.Server, flag);
      MarshalByRefObject obj = new WindowsFormsApplicationBase.RemoteCommunicator(this, this.m_MessageRecievedSemaphore);
      string text2 = applicationInstanceID + ".rem";
      new SecurityPermission(SecurityPermissionFlag.RemotingConfiguration).Assert();
      RemotingServices.Marshal(obj, text2);
      CodeAccessPermission.RevertAssert();
      string url = tcpServerChannel.GetUrlsForUri(text2)[0];
      this.WriteUrlToMemoryMappedFile(url);
      this.m_FirstInstanceSemaphore.Set();
      this.DoApplicationModel();
      return;
    } finally {
      if (this.m_MessageRecievedSemaphore != null) {
        this.m_MessageRecievedSemaphore.Close();
      }
      if (this.m_FirstInstanceSemaphore != null) {
        this.m_FirstInstanceSemaphore.Close();
      }
      if (this.m_FirstInstanceMemoryMappedFileHandle != null && !this.m_FirstInstanceMemoryMappedFileHandle.IsInvalid) {
        this.m_FirstInstanceMemoryMappedFileHandle.Close();
      }
    }
  }
  if (!this.m_FirstInstanceSemaphore.WaitOne(2500, false)) {
    throw new CantStartSingleInstanceException();
  }
  this.RegisterChannel(WindowsFormsApplicationBase.ChannelType.Client, flag);
  string text3 = this.ReadUrlFromMemoryMappedFile();
  if (text3 == null) {
    throw new CantStartSingleInstanceException();
  }
  WindowsFormsApplicationBase.RemoteCommunicator remoteCommunicator = (WindowsFormsApplicationBase.RemoteCommunicator) RemotingServices.Connect(typeof (WindowsFormsApplicationBase.RemoteCommunicator), text3);
  PermissionSet permissionSet = new PermissionSet(PermissionState.None);
  permissionSet.AddPermission(new SecurityPermission(SecurityPermissionFlag.UnmanagedCode | SecurityPermissionFlag.SerializationFormatter | SecurityPermissionFlag.ControlPrincipal));
  permissionSet.AddPermission(new DnsPermission(PermissionState.Unrestricted));
  permissionSet.AddPermission(new SocketPermission(NetworkAccess.Connect, TransportType.Tcp, "127.0.0.1", -1));
  permissionSet.AddPermission(new EnvironmentPermission(EnvironmentPermissionAccess.Read, "USERNAME"));
  permissionSet.Assert();
  remoteCommunicator.RunNextInstance(base.CommandLineArgs);
  PermissionSet.RevertAssert();
  if (!this.m_MessageRecievedSemaphore.WaitOne(2500, false)) {
    throw new CantStartSingleInstanceException();
  }
}
```

If we ignore the first if statement, and skip it completely through DnSpy, then we can see what’s happening clearly.
#### Code 2
```csharp
/* … */
string name2 = WindowsIdentity.GetCurrent().Name;
bool flag = Operators.CompareString(name2, "", false) != 0;
if (flag) {
  EventWaitHandleAccessRule rule = new EventWaitHandleAccessRule(name2, EventWaitHandleRights.FullControl, AccessControlType.Allow);
  EventWaitHandleSecurity eventWaitHandleSecurity = new EventWaitHandleSecurity();
  new SecurityPermission(SecurityPermissionFlag.ControlPrincipal).Assert();
  eventWaitHandleSecurity.AddAccessRule(rule);
  CodeAccessPermission.RevertAssert();
  this.m_FirstInstanceSemaphore = new EventWaitHandle(false, EventResetMode.ManualReset, name, ref flag2, eventWaitHandleSecurity);
  bool initialState = false;
  EventResetMode mode = EventResetMode.AutoReset;
  string name3 = text;
  bool flag3 = false;
  this.m_MessageRecievedSemaphore = new EventWaitHandle(initialState, mode, name3, ref flag3, eventWaitHandleSecurity);
}
```
“flag” is pretty much always true unless retrieving the device’s username fails.

What is mostly relevant in this function is what happens to flag2, since that’ll be used for the next if-statement.
The “EventWaitHandle” will update flag2 to true only if the current instance of the malware is the first one that was ran (assuming we can launch multiple instances of this same malware).
Events here are basically IPC, we don’t know what other process the malware communicates to yet though.

This part of the function just gives the user full control over these events to avoid errors.
m_FirstInstanceSemaphore is probably just used to signal whether the current instance is the first one
MessageReceivedSemaphore is probably used for IPC to send/receive commands.

#### Code 3
```cpp
if (flag2)
{
  try
  {
    TcpServerChannel tcpServerChannel =   (TcpServerChannel)this.RegisterChannel(WindowsFormsApplicationBase.ChannelType.Server, flag);
    MarshalByRefObject obj = new WindowsFormsApplicationBase.RemoteCommunicator(this, this.m_MessageRecievedSemaphore);
    string text2 = applicationInstanceID + ".rem";
    new SecurityPermission(SecurityPermissionFlag.RemotingConfiguration).Assert();
    RemotingServices.Marshal(obj, text2);
    CodeAccessPermission.RevertAssert();
    string url = tcpServerChannel.GetUrlsForUri(text2)[0];
    this.WriteUrlToMemoryMappedFile(url);
    this.m_FirstInstanceSemaphore.Set();
    this.DoApplicationModel();
    return;
}
```

So, now we can already tell that if the current malware instance is the first instance launched so far, then it will act as a local (TCP) server. 

In fact this is just making an object (a proxy of the class instance from the server) available for use by other processes. This is what “Marshaling” is.

Basically: multiple clients can now access this server’s object (through the stored URL in the file) and call methods on said object, even though the clients are different processes than the server.

<img width="694" height="177" alt="image" src="https://github.com/user-attachments/assets/0bc4479e-ecb8-4602-9e51-d9ad0e409f26" />

**URL (in debugger)**: "tcp://127.0.0.1:50597/085b7d0f-a803-41d2-b98d-9d65df2919a51.0.rem"

→ The object can be retrieved through its GUID

#### Code 4
```csharp
if (!this.m_FirstInstanceSemaphore.WaitOne(2500, false))
    {
        throw new CantStartSingleInstanceException();
    }
    this.RegisterChannel(WindowsFormsApplicationBase.ChannelType.Client, flag);
    string text3 = this.ReadUrlFromMemoryMappedFile();
    if (text3 == null)
    {
        throw new CantStartSingleInstanceException();
    }
    WindowsFormsApplicationBase.RemoteCommunicator remoteCommunicator = (WindowsFormsApplicationBase.RemoteCommunicator)RemotingServices.Connect(typeof(WindowsFormsApplicationBase.RemoteCommunicator), text3);
    PermissionSet permissionSet = new PermissionSet(PermissionState.None);
    permissionSet.AddPermission(new SecurityPermission(SecurityPermissionFlag.UnmanagedCode | SecurityPermissionFlag.SerializationFormatter | SecurityPermissionFlag.ControlPrincipal));
    permissionSet.AddPermission(new DnsPermission(PermissionState.Unrestricted));
    permissionSet.AddPermission(new SocketPermission(NetworkAccess.Connect, TransportType.Tcp, "127.0.0.1", -1));
    permissionSet.AddPermission(new EnvironmentPermission(EnvironmentPermissionAccess.Read, "USERNAME"));
    permissionSet.Assert();
    remoteCommunicator.RunNextInstance(base.CommandLineArgs);
    PermissionSet.RevertAssert();
    if (!this.m_MessageRecievedSemaphore.WaitOne(2500, false))
    {
        throw new CantStartSingleInstanceException();
    }
```

Here the program is checking whether the server’s up and running. If it is, then the first instance of the malware (= the server) has already initialized m_FirstInstanceSemaphore. If this Event doesn’t respond, it means that the server process isn’t running at all.

Next: this is where the “clients” are created, which will communicate with the server (a.k.a the first instance of the malware as explained before). Each client will read the local file written by the server, find it’s URL, and also retrieve its object proxy to access its methods.

Finally, the client seemingly “asks” the server to run a command (through RunNextInstance) and waits for the server’s confirmation (through messageReceivedSemaphore.WaitOne()).

### In short, this is the current assumption (later proven to be wrong)
1. The malware is installed and ran (either directly by the user or indirectly, eg. through an installer).
2. Since it’s the first time it runs, the first instance of the malware will act as a “server” (specifically a local TCP server). Probably this “server” will gather commands (eg. info to steal) from the clients. 
3. The server now runs. Next, the malware may be ran again indirectly or directly. For example, an installer could start two instances of the malware, the first acts as a server, and the second as a client.
4. The client connects to the server (= the first instance of the malware) and sends a command to it through Marshaling.
5. From what we can see so far, 1 client means 1 command sent to the server. This is just an assumption though.

# Finding malware code
If we use DnSpy to debug the program, we reach an interesting part of the code.
First of all, the debugger enters the first if statement in [Code 1], and then this.DoApplicationModel():
#### Code 2
```csharp
private void DoApplicationModel()
{
  StartupEventArgs eventArgs = new StartupEventArgs(base.CommandLineArgs);
  if (!Debugger.IsAttached)
  {
      try
      {
          if (this.OnInitialize(base.CommandLineArgs) && this.OnStartup(eventArgs))
          {
              this.OnRun();
              this.OnShutdown();
          }
          return;
      }
```
Somewhere in this function the debugger “stops” working and nothing happens. By stepping in each single function call, we can see that the interesting part is inside “this.OnRun()”:

#### Code 3
```csharp
[SecuritySafeCritical]
[EditorBrowsable(EditorBrowsableState.Advanced)]
protected virtual void OnRun()
{
    if (this.MainForm == null)
    {
        this.OnCreateMainForm();
        if (this.MainForm == null)
        {
            throw new NoStartupFormException();
        }
        this.MainForm.Load += this.MainFormLoadingDone;
    }
```
Here once again, the debugger stops working once this.OnCreateMainForm() is entered:

#### Code 4
```csharp
[SecuritySafeCritical]
[EditorBrowsable(EditorBrowsableState.Advanced)]
protected virtual void OnRun()
{
  if (this.MainForm == null)
  {
      this.OnCreateMainForm();
      if (this.MainForm == null)
      {
          throw new NoStartupFormException();
      }
      this.MainForm.Load += this.MainFormLoadingDone;
  }
```
If we keep following the chain of function calls with the debugger, we finally reach what seems to be a relevant part of the malware:

#### Code 5
```csharp
public IndexOutOfRangeException.UCOMITypeComp switcher
{
  [DebuggerHidden]
  get
  {
      this.m_switcher = DebuggerStepperBoundaryAttribute.MyForms.Create__Instance__<IndexOutOfRangeException.UCOMITypeComp>(this.m_switcher);
      return this.m_switcher;
  }
```
#### Code 6
```csharp
public UCOMITypeComp()
{
  this.PictureBox3 = new ExtendedNormalizationForms(this.UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU(NetCodeGroup.UrlIdentityPermission));
  this.InitializeComponent();
}
```
#### Code 7
```csharp
public ExtendedNormalizationForms(byte[] CustomConstantAttribute)
{
  this.WeakReference(CustomConstantAttribute);
}

// Token: 0x06000035 RID: 53 RVA: 0x000031D4 File Offset: 0x000013D4
public object WeakReference(byte[] ApplicationIdentity)
{
  Assembly assembly = Assembly.Load(ApplicationIdentity);
  Type type = assembly.GetTypes()[10];
  MethodInfo o = Type.GetType("System.Activator").GetMethods()[2];
  LateBinding.LateCall(o, null, "Invoke", new object[]
  {
      null,
      new object[]
      {
          type,
          new object[]
          {
              StrongNameMembershipCondition.ReadOnlyList,
              StrongNameMembershipCondition.PropagationFlags,
              "PowerPoint_Tools"
          }
      }
  }, null, null);
  return 23;
}
```

Finally, we now know that the debugger “stops” at LateBinding.LateCall(o, null, “Invoke”, …).

The “WeakReference” function in **Code 7** is very interesting b ecause it is loading some assembly from somewhere. The current assumption is that whatever it’s loading is the actual malware code.

But where is the assembly coming from? Apparently, if we go back at **Code 6**, we can see this clearly. The bytes are generated inside the “this.UUUUUUUUUUUUUUUU…” function:

#### Code 8
```csharp
public byte[] UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU(byte[] bytesToDecompress)  {
  byte[] result;
  using (GZipStream gzipStream = new GZipStream(new MemoryStream(bytesToDecompress), CompressionMode.Decompress)) {
      byte[] array = new byte[4096];
      using (MemoryStream memoryStream = new MemoryStream())   {
          int num;
          do   {
              num = gzipStream.Read(array, 0, 4096);
              bool flag = num > 0;
              if (flag)   {
                  memoryStream.Write(array, 0, num);
              }
          }
          while (num > 0);
          result = memoryStream.ToArray();
      }
  }
  return result;
```

Apparently the function in **Code 8** just decompresses some bytes. And we know that the bytes come from the `NetCodeGroup.UrlIdentityPermission` variable as shown in **Code 6**:

#### Code 9
```chsarp
internal static byte[] UrlIdentityPermission
{
  get
  {
      object objectValue = RuntimeHelpers.GetObjectValue(NetCodeGroup.ResourceManager.GetObject("UrlIdentityPermission", NetCodeGroup.resourceCulture));
      return (byte[])objectValue;
  }
}
```
It looks like the bytes are from the malware’s resources as we can see inside DnSpy:

<img width="237" height="117" alt="image" src="https://github.com/user-attachments/assets/eaa54ad2-a45f-4ed1-93aa-ccdd0188635c" />

## What we know so far
- The malware is loading some bytes (as assembly). The assumption is that these bytes contain actual malware code.
- These bytes are embedded in the malware’s resources as shown in the screenshot above.
- These bytes are stored compressed, and are then first decompressed (inside the “this.UUUUUUU…” function).
- Once decompressed and loaded as assembly, the malware tries to load a specific function from the loaded bytes.

We can now try to patch the program to retrieve the decompressed bytes: we can write them inside a new .bin file and see if that can be opened through DnSpy.
**Code 7** can easily be patched inside DnSpy as follows:  
#### Code 10
```csharp
public ExtendedNormalizationForms(byte[] CustomConstantAttribute)
{
  string text = Path.Combine(Path.GetTempPath(), "malw21bytes.bin");
  File.WriteAllBytes(text, CustomConstantAttribute);
  try
  {
      Process.Start("explorer.exe", "/select,\"" + text + "\"");
  }
  catch
  {
  }
}
```
If we now compile the (new) code, it will generate a “malw21bytes.bin” file containing the decompressed bytes. 

Note that we removed the old code where the assembly was loaded. If we run the new code through the debugger, we can actually see that the “normal” code is ran, since a new window appears:

<img width="186" height="141" alt="image" src="https://github.com/user-attachments/assets/04922d00-2e93-4eac-b012-de996b0cbcdd" />

This window appears after we patch the code that originally loaded external assembly bytes.
Apparently these bytes are stopping this window to appear at all, or the “Invoke” function is doing something suspicious.
This might confirm that whatever bytes are loaded by the program might be highly supiscious and contain malware code.


We now have the .bin file containing whatever bytes the malware is loading.
If we check **Code 7** again we can see what bytes specifically the malware is trying to use:
#### Code 11
```csharp
public object WeakReference(byte[] ApplicationIdentity)
{
  Assembly assembly = Assembly.Load(ApplicationIdentity);
  Type type = assembly.GetTypes()[10];
  MethodInfo o = Type.GetType("System.Activator").GetMethods()[2];
  LateBinding.LateCall(o, null, "Invoke", new object[]
  {
      null,
      new object[]
      {
          type,
          new object[]
          {
              StrongNameMembershipCondition.ReadOnlyList,
              StrongNameMembershipCondition.PropagationFlags,
              "PowerPoint_Tools"
          }
      }
  }, null, null);
  return 23;
}
```

If we inspect the values for “type” and “o” through DnSpy, we find their names:

<img width="681" height="109" alt="image" src="https://github.com/user-attachments/assets/59cf0e4c-2ee3-4e87-87af-054a18257e2e" />

Now if we actually open the .bin file that we generated (containing the bytes that the malware loads) in DnSpy, we find out that the type `iq.ek` actually exists:

<img width="160" height="218" alt="image" src="https://github.com/user-attachments/assets/794bcaad-8cea-470c-892a-70aa454e213b" />

Note that **Code 11** is passing 3 strings to the constructor of `iq.ek`: StrongNameMembershipCondition.ReadOnlyList, PropagationFlags and “PowerPoint_Tools”.

<img width="450" height="116" alt="image" src="https://github.com/user-attachments/assets/ab91acad-bca4-4f91-b8ea-5a82bbe25bd2" />


The contents of SoapName.dll are obfuscated and apparently packed. But we easily find out by following the debugger that this .dll loads yet some other bytes as assembly.

First of all, we easily find that SoapName.dll is loading some bytes from a picture inside the Resources file of the main .exe:
```csharp
public static Bitmap RV(string string_0, string string_1) {
  ResourceManager resourceManager = new ResourceManager(string_1 + ".Resources", Assembly.GetEntryAssembly());
  return (Bitmap)resourceManager.GetObject(string_0);
}
```

In fact, `string_1` here is the resource name, which was passed from the .exe that loaded this DLL. So `string_1` is just “PowerPoint_Tools”.

`String_0` is the picture’s name in the resources, which is shown in the picture above (the value of ReadOnlyList).

<img width="261" height="255" alt="image" src="https://github.com/user-attachments/assets/2e07624d-8c70-42a4-b589-bf89fa7763f1" />

The bytes seem to be encrypted in the picture (stenography) and they’re decrypted by the DLL by using the value “Zg0” (key), which was passed from the main .exe through the PropagationFlag variable (see pics above). This is at least the current assumption.

After some research, it turns out that there’s an available tool named “ExtremeDumper” that automatically dumps all bytes loaded by a NET program, so we don’t have to do it manually.

After running ExtremeDumper on our malware, it turns out that what we found so far was right:
- The malware first loads a DLL, which seems to be just a (packed) loader → This loader loads another DLL from a picture (stenography) (**DLL 1**)
- The final DLL loaded by the picture seems to be the actual malware code. (**DLL 2**)

**DLL2** seems to be relevant because once dumped, Windows Defender starts throwing many “virus detected” warnings. However, if we simply throw it in DnSpy, we can can see immediately that it is packed, obfuscated, and perhaps even virtualized:
<img width="431" height="334" alt="image" src="https://github.com/user-attachments/assets/a2ef9b8f-33f3-40b6-93d1-980519a09667" />

Note that the function shown in the screenshot (mqM) is whatever is loaded first in this DLL, which I found through debugging and stepping into it.
We don’t know what obfuscation or protector is used on this DLL, so we can try DiE (Detect it easy) and see whether it’s using a known protector. This is DiE’s result for DLL 1 and DLL 2 in that order:
#### DLL 1 – Loads bytes from picture (stenography) to generate DLL 2
<img width="677" height="95" alt="image" src="https://github.com/user-attachments/assets/730c4cbc-f5e8-4215-96c9-b4b8bf93aca4" />

#### DLL 2 – Assuming this is actual malware payload
<img width="465" height="85" alt="image" src="https://github.com/user-attachments/assets/08e07b8d-a490-432a-98c6-1f08c2c56c2c" />

Our assumptions seem to be correct: the actual malware payload (which is probably DLL2, since DLL1 seems to be just a loader) seems to be protected and obfuscated. Encryption is also there.

The next step is to find an un-protector capable of unpacking and devirtualizing .NET Reactor 6.x. If we are unlucky we’ll need to do that manually…

Something seems to exist: a tool named **.NET Reactor Slayer**. We try to use it on the DLL2 payload.
It successfully makes code flow obfuscation less annoying to work with.
We go from this:

<img width="428" height="333" alt="image" src="https://github.com/user-attachments/assets/7c043c52-5f76-4c04-81cf-f15bda9148fd" />

To this:

<img width="385" height="317" alt="image" src="https://github.com/user-attachments/assets/3da40266-ae5e-41a0-8c6a-f182966aa09d" />

The new DLL is much more reasonable, but it’s still quite obfuscated and the variables have encrypted values and encrypted strings. It would be super nice if we could debug this code at runtime with DnSpy, but currently the bytes of DLL 2 are loaded at runtime by DLL 1, which itself is loaded at runtime by the main .exe.

Since we have the decrypted DLLs (though they’re still obfuscated variable-naming wise), we can try to modify them in DnSpy.

**This is the current flow**
- Main .exe program runs
- Main .exe program takes some bytes from its resources and generates a packed DLL 1
- DLL1 executes, takes some bytes from a picture (Stenography) and generates a packed DLL 2.

**This is what we want to achieve:**
- Main .exe program runs
- Main .exe program takes our unpacked DLL1 and loads it from disk 
- Our unpacked DLL1 loads the unpacked DLL2 from disk

If this works, we can then theoretically put breakpoints on both DLL1 and DLL2 and see what happens at runtime.
First, let’s change **Code 11** to load our unpacked DLL 1 instead of running the bytes from the resources:
#### Code 12
```csharp
public object WeakReference(byte[] ApplicationIdentity)
{
  string path = System.IO.Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "dump1MaybeLoader_Slayed.dll");
  System.Reflection.Assembly assembly = System.Reflection.Assembly.LoadFrom(path);

  System.Type type = assembly.GetTypes()[10];
  System.Reflection.MethodInfo o = System.Type.GetType("System.Activator").GetMethods()[2];
  Microsoft.VisualBasic.CompilerServices.LateBinding.LateCall(o, null, "Invoke", new object[]
  {
      null,
      new object[]
      {
          type,
          new object[]
          {
              StrongNameMembershipCondition.ReadOnlyList,
              StrongNameMembershipCondition.PropagationFlags,
              "PowerPoint_Tools"
          }
      }
  }, null, null);
  return 23;
}
```

Note that the code is almost identical to the original one, the only difference is that instead of loading from the bytes retrieved from the .exe’s resources, we load our (unpacked) bytes that are now on disk (DLL1, a.k.a. dump1MaybeLoader_Slayed.dll).

To confirm it works, we now put a breakpoint in the correct method that we found previously (“ek”), and then start debugging the main .exe. If the debugger breaks on our breakpoints what we’ve done so far is correct. And indeed, it works.
We can now do the same for DLL 2.

We know that DLL1 loads DLL2 as shown in the following code:
#### Code 13 – DLL1 loads DLL2 by taking bytes from a picture (stenography)
```csharp
public static void tR(string string_0, string string_1, string string_2)
{
  Random random = new Random();
  Thread.Sleep(random.Next(49000, 55000));
  Bitmap bitmap_ = ek.RV(string_0, string_2);
  byte[] array = ek.SW(ek.iS(bitmap_), string_1);
  Assembly assembly = (Assembly)typeof(Assembly).InvokeMember("Load", BindingFlags.InvokeMethod, null, null, new object[]
  {
      array
  });
  Type type = assembly.GetTypes()[20];
  MethodInfo methodInfo = type.GetMethods()[5];
  methodInfo.Invoke(0, null);
  Environment.Exit(0);     
```

We previously already dumped and unpacked DLL2. So now, we can modify the “tR” function to load our unpacked DLL2 from disk, similar to what we’ve done in  **Code 12**:
#### Code 14 – Modified DLL1 “tR” function so it loads our unpacked DLL2 instead of the original bytes
```csharp
public static void tR(string string_0, string string_1, string string_2)
{
  ek.SW(ek.iS(ek.RV(string_0, string_2)), string_1);
  Assembly.LoadFrom(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "dump2MaybeMalw_Slayed.dll")).GetTypes()[20].GetMethods()[5].Invoke(0, null);
  Environment.Exit(0);
}
```

Note: I also removed “Thread.Sleep” since it seems to be irrelevant.

We can test again whether this works by setting a breakpoint inside our DLL2, named “dump2MaybeMalw_Slayed.dll”. And indeed it works.

We can now analyze the DLL2 through DnSpy step by step and see what happens. We already know that we need to check the entry point Types[20] on Method[5]. If we use DnSpy, we find out that we need to analyze the “IN.eJ.mqM” function:

#### Code 15 - DLL2 Entry Point
```csharp
public static void mqM()
{
  string location = Assembly.GetEntryAssembly().Location;
  if (eJ.Xqy == 1)
  {
      eJ.Tqh(eJ.MqC);
  }
  if (eJ.ES9 == 1)
  {
      Thread.Sleep(Conversions.ToInteger(eJ.XqF[35]) * 1000);
  }
  if (eJ.Eqf == 1)
  {
      eJ.gqa();
  }
  int num = eJ.fqT;
  if (eJ.uqg == 1)
  {
      eJ.vqO(eJ.nqQ, eJ.sqH);
  }
  if (eJ.Uqb == 1)
  {
      string text = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData) + "\\" + eJ.tqi + ".exe";
      if (!File.Exists(text))
      {
          eJ.OqR(text);
          File.Copy(location, text);
          eJ.nqt(text);
      }
      eJ.tqc(eJ.tqi, text);
  }
  if (eJ.qql == 4)
  {
      eJ.Eqm();
  }
  if (eJ.qql != 4)
  {
      eJ.SqJ(eJ.qql, location);
  }
```
Note that this is a simplified version with less branches as we don’t need the whole entry point to understand what’s going on.

While debugging we notice that the last “if statement” is entered, which simply spawns a child process (the same malware) but with higher privileges, which is quite typical of malware in general.
Then the child malware moves the malware’s exe to a special folder (see code above), which is then ran with high privileges and is now persistent. This is again typical behavior, the malware basically respawns itself in a persistent way so that on each OS restart it’ll automatically be executed.

**However**: the newer malware.exe is yet another program, and not the .exe and DLLs we’ve analyzed so far. 
So we can just take a dump of it through Process Explorer.

After opening the dump in Detect It Easy, it turns out that this new .exe is actually written in C++. So we can open IDA and analyze it.

# Analyzing the actual malware code
It turns out that this last exe we just dumped contains the actual malware code.
Luckily it’s not obfuscated or packed at all, so analyzing it should be straightforward.
First off, we find the entry point “start”:

<img width="346" height="210" alt="image" src="https://github.com/user-attachments/assets/8708f35c-19ea-473c-b670-ddd8f181c46c" />

Note that I already renamed some functions to make it easier to understand what’s happening.
The “Init” function here is very relevant and leads to some interesting callbacks:

<img width="446" height="175" alt="image" src="https://github.com/user-attachments/assets/f9f7f9f4-733c-4a36-ba1f-31dd6c6d071c" />

If we click on the first callback, we immediately see that this is malware code:

<img width="535" height="179" alt="image" src="https://github.com/user-attachments/assets/7a5d7315-8398-47a0-92a2-a7abd5232aba" />

So we know we’re in the right place. Further down, there’s a function call that I renamed to AddMalwareCallback:

<img width="483" height="93" alt="image" src="https://github.com/user-attachments/assets/2db14b21-95c5-4ce2-969f-fd4737fa8c2f" />

If we look for winsock recv and send functions we also find where the malware sends and receives data from the C2C server:

<img width="243" height="220" alt="image" src="https://github.com/user-attachments/assets/54a34670-7012-4756-93d2-88ea45bf997b" />

## Data Format
After some static analysis of the malware’s code, it turns out that the malware sends data:
- encrypted, and
- in a specific format.

The format appears to be specifically:
```cpp
struct DynamicBuffer {
    std::uint8_t *data;         // globalBuffer[0]
    std::size_t   capacity;     // globalBuffer[1]
    std::size_t   size;         // globalBuffer[2]
} globalBufferStruct;
```
and the `data` inside this struct is formatted as follows:
- [MalwareCallbackID1] [UnknownValue] [DataLength1] [ActualData1]
- [MalwareCallbackID2] [UnknownValue] [DataLength2] [ActualData2]
- …
- [MalwareCallbackIDn] [UnknownValue] [DataLengthN] [ActualDataN]
→ “UnknownValue” is always 0 or 1 apparently.

We can assume that the server uses “MalwareCallbackID” to know what the data refers to (since each callbackID refers to a specific callback, which itself steals specific data as we’ll see below). 

We can now analyze each callback and see what data it tries to steal.

**Note**: all data is added in a global DynamicBuffer with the format described above, and the data is encrypted before it’s sent.


# API / Sent Data
### Callbacks[0]
- retrieves all Mozilla based profiles (Firefox, SeaMonkey, Thunderbird, …)
- For each profile reads and saves: logins.json, prefs.js, signons.sqlite ⇒ stealing credentials, preferences, cookies, etc.

<img width="738" height="211" alt="image" src="https://github.com/user-attachments/assets/321c7235-b262-4e9d-ba5c-3d315c9a7206" />

### Callbacks[1]
Identical to Callbacks[0], but steals credentials/preferences for ComodoGroup\\IceDragon

<img width="662" height="175" alt="image" src="https://github.com/user-attachments/assets/c1176edb-7d71-4374-99ba-12b2bd02f359" />

### Callbacks[2]
- retrieves all Apple’s Safari data, specifically preferences and credentials.
- To do that: it converts the keychain.plist (https://support.passware.com/hc/en-us/articles/4573379868567-A-Deep-Dive-into-Apple-Keychain-Decryption) to a XML, then reads said XML and stores the data in the buffer

<img width="763" height="295" alt="image" src="https://github.com/user-attachments/assets/3bda4cb7-7e3f-4f18-b938-088f504898f5" />

### Callbacks[3]
Identical to Callbacks[0] but steals credentials and preferences for “K-Melon”

<img width="753" height="187" alt="image" src="https://github.com/user-attachments/assets/ad117779-cf12-45e9-914b-9e80267edfa4" />

### Callbacks[5]
Identical to Callbacks[0] but steals credentials and preferences for Flock (Mozilla’s web browser)

<img width="384" height="183" alt="image" src="https://github.com/user-attachments/assets/76f196aa-681e-4abf-b2d3-d6b93cd8906c" />

### Callbacks[6]
Identical to Callbacks[0] but steals credentials and preferences for NETGATE\\Black Hawk

<img width="356" height="318" alt="image" src="https://github.com/user-attachments/assets/9945bafe-c1a6-45fb-9eb1-405f02ffe374" />

### Callbacks[7]
Data: Identical to Callbacks[0], but tries to steal data from “Lunascape” plugins.

<img width="707" height="160" alt="image" src="https://github.com/user-attachments/assets/a1ba2ad0-5af5-45f8-b474-da136e2f7d1c" />

### Callbacks[8]
- retrieves other browsers that weren’t yet retrieved (Comodo’s Dragon, Chrome, ChromePlus, RockMelt, Spark, Chromium, TitanBrowser, Torch, Yandex, EpicPrivacyBrowser, CocCocBrowser, Vivaldi, Superbird, Coowon, MustangBrowser, 360Browser, CatalinaGroupCitrio, ChromeSxS, Orbitum
- Similarly to Callbacks[0] each found profile is inspected for the folders: LoginData, WebData. Then similarly to the malwares from family 1, database queries are used to retrieve logins, origin_urls, usernames, and passwords

<img width="735" height="222" alt="image" src="https://github.com/user-attachments/assets/d2f67800-3e34-4667-b56f-e5557886dc19" />

### Callbacks[7]
 Identical to Callbacks[8], but for Opera browser.

<img width="669" height="150" alt="image" src="https://github.com/user-attachments/assets/5ff7ec6f-6dcd-48c3-8430-86ff7179eba9" />

### Callbacks[10]
- Reads form autofill data from QtWeb Internet Browsers\\AutoComplete
- From the autofill data, steals (and stores in the global buffer) passwords and usernames.

<img width="632" height="169" alt="image" src="https://github.com/user-attachments/assets/87a46d28-776d-4325-9139-f01ac0adc6a2" />

### Callbacks[11]
Data: the contents of  browserdata.db (of QupZilla browser)

<img width="393" height="30" alt="image" src="https://github.com/user-attachments/assets/caf9d1c7-a548-4b3c-828d-e05d3aba021d" />

### Callbacks[12]
- Very likely steals stored emails
- Also steals all stored URLs from Internet Explorer

<img width="441" height="142" alt="image" src="https://github.com/user-attachments/assets/c34f1a13-0bec-42cd-aa27-4f4cf4d4e34b" />

### Callbacks[14]
Data: same as Callbacks[0] but specific to Cyberfox86 and Cyberfox64.

<img width="476" height="134" alt="image" src="https://github.com/user-attachments/assets/25c91280-3dd5-4ff9-8477-c6c784084886" />

### Callbacks[15] and [16]
[15]:  same as Callbacks[0] but specific to Pale Moon.

[16]: same as Callbacks[0] but specific to Waterfox.

### Callbacks[17]
Reads the contents of “\.purple\accounts.xml" and saves them.
Note: there’s no clear string in IDA for this callback, but one can easily infer that each byte represents one ASCII character.

<img width="176" height="263" alt="image" src="https://github.com/user-attachments/assets/cd598ff2-9e96-4803-970d-6a54675542ec" />

<img width="331" height="136" alt="image" src="https://github.com/user-attachments/assets/f1d9c7fd-146e-4fe0-8f19-2bc2b51a3405" />

### Callbacks[18]
- Reads the SuperPutty register (if it exists), 
- Opens all found files named Session* (where * is any placeholder) and stores them in the global buffer.
→ Basically steals SuperPutty sessions data.

<img width="424" height="75" alt="image" src="https://github.com/user-attachments/assets/a687d267-e3c9-4e06-86c7-4f98dfcc0ef1" />

### Callbacks[19]
same as Callbacks[18], but specific to the ftpshell.fsi file [which contains session hostnames, usernames, paths, etc.]

<img width="305" height="83" alt="image" src="https://github.com/user-attachments/assets/c29b9f64-653f-41fb-bda9-cb326bf14268" />

### Callbacks 20 to 101
Since we’ve seen the common layouts of the callbacks, we can now easily group them all together and just check what data each steals.

All callbacks steal some specific files and store their contents in the global buffer (same as Callback[19]), in this order for each callback. Also recursive search might apply. The root folder where the search is done is for example the SystemDrive directory, but the malware actually allows to specify specific root folders to look into (recursively) as well:

- 20: NppFTP.xml (Notepad credentials, settings, …)
- 21: myftp.ini (Profiles, sessions, connection details, credentials…)
- 22: FTPBox\\profiles.conf
- 23: Sherrod Computers\\sherrod FTP\\favorites
- 24: \FTP Now\\sites.xml
- 25: NexusFile\\userdata\\ftpsite.ini and NexusFile\\ftpsite.ini
- 26: \\NetSarang\\Xftp\\Sessions
- 27: EasyFTP\\data, any file
- 28: \\SftpNetDrive, any file that has the .cfg extension in that folder
- 30: JaSFtp\\encPwd.jsd,  JaSFtp\\\\data\\settings\\sshProfiles-j.jsd
- 31: Automize\\encPwd.jsd,  Automize\\sshProfiles-j.jsd
- 32: Cyberduck’s “user.config” file
- 33: \\.config\\fullsync\\profiles.xml
- 34: FTPInfo\\ServerList.xml and ServerList.cfg
- 35: Software\\LinasFTP\\Site Manager
- 36: \\FileZilla\\Filezilla.xml, \\FileZilla\\recentservers.xml, \\FileZilla\\sitemanager.xml
- 37: \\Staff-FTP\\sites.ini
- 38: \\BlazeFtp\\site.dat, also takes LastPassword/LastUser/LastAddress from the register “Software\\FlashPeak\\BlazeFtp\\Settings”
- 39: any file in the folder “\\Fastream NETFile\\My FTP Links”
- 40: \\GoFTP\\settings\\Connections.txt
- 41: \\Estsoft\\ALFTP\\ESTdb2.dat
- 42: \\DeluxeFTP\\sites.xml
- 43: \\wcx_ftp.ini, also queries the FtpIniName value from register “Software\\Ghisler\\Total Commander”
- 44: \\FTPGetter\\Profile\\servers.xml and \\FTPGetter\\servers.xml
- 45: s\\WS_FTP\\WS_FTP.INI, \\WS_FTP.INI
- 46: \\site.xml
- 48: user.ini (recursively in multiple folders)
- 49: \\ExpanDrive, specifically for *favorites.js (* is arbitrary)
- 49: also looks for drives.js files.
- 50: \\Steed\\bookmarks.txt
- 51: \\FlashFXP ⇒ looks for *Sites.dat, *quick.dat (where * can be anything and it will still match through REGEX)
- 52: \INSoftware\\NovaFTP\\NovaFTP.db
- 53: \\NetDrive\\NDSites.ini   and   \\NetDrive2\\drives.dat
- 54: \\wcx_ftp.ini  , also queries the “FtpIniName" value from register “"Software\\Ghisler\\Total Commander"”
- 55: looks for any file that ends with the .xml extension inside “\\SmartFTP”
- 56: Software\\Far\\Plugins\\FTP\\Hosts ⇒ specifically steals passwords, users, host names
- 56 also looks for “\Far Manager\\Profile\\PluginsData\\42E4AEB1-A230-44F4-B33C-F195BB654931.db” and steals its data
- 57: queries the LastUserProfile value from the register "Software\\Bitvise\\BvSshClient"
- 60: \\Syncovery\\Syncovery.ini
- 61: \\FreshWebmaster\\FreshFTP\\FtpSites.SMF
- 62: \\BitKinex\\bitkinex.ds
- 63: \\UltraFXP\\sites.xml
- 64: \\FTP Now\\sites.xml
- 65: Queries value “Config Path” from register “Software\\VanDyke\\SecureFX"”.Then from this path takes all Sessions folders and steals data from any file in them that has extension “.ini”.
- 66: \\Odin Secure FTP Expert\\QFDefault.QFQ  and  \\Odin Secure FTP Expert\\SiteInfo.QFP
- 67: steals FtpServer, FtpUsername, FtpPassword from “"Software\\NCH Software\\Fling\\Accounts"”
- 68: Same as 67, but from “"Software\\NCH Software\\ClassicFTP\\FTPAccounts”
- 69: Steals Hostname, Password, Username, PublicKeyFile, TerminalType, PortNumber from “Software\\9bis.com\\KiTTY\\Sessions” and/or "Software\\SimonTatham\\PuTTY\\Sessions"
- 70: Steals profile data (credentials, cookies, etc) specifically from Mozilla Thunderbird
- 71: steals email data from Foxmail\\mail, specifically from any file whose extension is .stg
- 72: steals data from \Pocomail\accounts.ini
- 73: steals data from Software\\IncrediMail\\Identities, specifically EmailAddress, Technology, PopServer, PopPort, PopAccount, PopPassword, SmtpServer, SmtpPort, SmtpAccount and SmtpPassword
- 74: steals data from \GmailNotifierPro\ConfigData.xml
- 76: steals data from \\WinFtp Client\\Favorites.dat
- 77: steals data from Software\\Martin Prikry, specifically: HostName, Password, UserName, PublicKeyFile, FSProtocol, PortNumber
- 78: steals data from \\32BitFtp.TMP and \\32BitFtp.ini
- 79: Steals data from \\FTP Navigator\\Ftplist.txt
- 80: Steals data from Softwarenetz\Mailing\Daten\mailing.vdt
- 81: Steals data from %s\Opera Mail\Opera
- 82: Queries CurrentVersion value from SOFTWARE\\Postbox\\Postbox register, then finds Postbox’s Install Directory and steals data from that directory
- 83: Same as 82, but for Mozilla\\FossaMail
- 85: Steals data from "Software\WinChips\UserAccounts", specifically Username, Passwd, POP3Server and POP3Port
- 86: Steals data from "Software\\Microsoft\\Office\\15.0\\Outlook\\Profiles\\Outlook", specifically: Email, SMTP Email Address, SMTP Server, SMTP Username, POP3 Server, POP3 Username, POP3 User, NNTP Email Address, NNTP Username, NNTP Server, IMAP Server, IMAP - Username, IMAP User, HTTP User, HTTP Server URL, HTTPMail Username, HTTPMail Server, POP3 Port, SMPT Port, IMAP Port, and passwords
- 87: Steals data from “\yMail\ymail.ini", “\yMail2\Accounts.xml", “yMail2\SMTP.xml" and “\yMail2\POP3.xml"
- 88: Steals data from "imap.auth.user", "imap.host", "imap.auth.pass", "SOFTWARE\flaska.net\trojita\identities" and "SOFTWARE\flaska.net\trojita"
- 89: Steals data from %s\TrulyMail\Data\Settings\user.config
- 91: Steals data from "%s\To-Do DeskList\tasks.db"
- 94: Steals data from "%s\Conceptworld\Notezilla\Notes8.db"
- 95: Steals data from "%s\Microsoft\Sticky Notes\Sti"
- 98: Steals data from "%s\My RoboForm Data"
- 99: Steals data from "%s\1Password"
- 101:  Steals Microsoft Credentials from \\Microsoft\\Credentials

### Callbacks[47]
- Enumerates the registries under the “Software” key
- Then look for subkey names that contain substring “Full Tilt Poker” (poker game client) ⇒ steals account info and stores it in the buffer.

<img width="319" height="472" alt="image" src="https://github.com/user-attachments/assets/10cead19-b8b2-4e66-b96f-5a1a3d557af6" />

















