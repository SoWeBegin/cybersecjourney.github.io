Analysis of malware 2.3  – SHA256: 9d68a12426cf5945a7f852ad0ebfb745858e80a10368e5ef9468030fa95363e4

# Assumptions / Notes found with DIE (Detect It Easy)
- 1.1 DiE detects a packer heuristically → Strange overlay section
- 1.2 Environment: C/C++, Visual Studio 6.0 → Unmanaged .exe
- Architecture: x32

# Static & Dynamic analysis with IDA Pro / embedded win32dbg in IDA Pro
#### Code 1 - Entry Point
```cpp
void __noreturn start()
{
  char *v0; // esi
  int wShowWindow; // eax
  HMODULE ModuleHandleA; // eax
  int v3; // [esp-4h] [ebp-88h]
  char v4[4]; // [esp+14h] [ebp-70h] BYREF
  int v5; // [esp+18h] [ebp-6Ch] BYREF
  int v6; // [esp+1Ch] [ebp-68h]
  char v7[4]; // [esp+20h] [ebp-64h] BYREF
  char v8[4]; // [esp+24h] [ebp-60h] BYREF
  struct _STARTUPINFOA StartupInfo; // [esp+28h] [ebp-5Ch] BYREF
  CPPEH_RECORD ms_exc; // [esp+6Ch] [ebp-18h]

  ms_exc.registration.TryLevel = 0;
  _set_app_type(_crt_gui_app);
  dword_276254 = -1;
  dword_276258 = -1;
  *_p__fmode() = dword_27624C;
  *_p__commode() = dword_276248;
  dword_27625C = adjust_fdiv;
  nullsub_1();
  if ( !dword_275010 )
    _setusermatherr(UserMathErrorFunction);
  _setdefaultprecision();
  initterm(&First, &Last);
  v5 = dword_276244;
  _getmainargs(v8, v4, v7, dword_276240, &v5);
  initterm(&dword_275000, &dword_275004);
  v0 = acmdln;
  if ( *acmdln != 34 )
  {
    while ( (unsigned __int8)*v0 > 0x20u )
      ++v0;
    goto LABEL_8;
  }
  do
    ++v0;
  while ( *v0 && *v0 != 34 );
  if ( *v0 != 34 )
    goto LABEL_8;
  while ( 1 )
  {
    ++v0;
LABEL_8:
    if ( !*v0 || (unsigned __int8)*v0 > 0x20u )
    {
      StartupInfo.dwFlags = 0;
      GetStartupInfoA(&StartupInfo);
      if ( (StartupInfo.dwFlags & 1) != 0 )
        wShowWindow = StartupInfo.wShowWindow;
      else
        wShowWindow = 10;
      v3 = wShowWindow;
      ModuleHandleA = GetModuleHandleA(0);
      v6 = WinMain(ModuleHandleA, 0, v0, v3);
      exit(v6);
    }
  }
}
```

After quickly checking each function call, the interesting things seem to be happening inside the “WinMain” function, which just calls `sub_2715A0`:
#### Code 2
```cpp
int sub_2715A0()
{
  // local variable declarations generated by IDA
  // ...
  v16 = (int (__stdcall *)(_DWORD, wchar_t *, int))sub_2719E0(v17, -1824012015);
  v15 = v16(0, aIeucizeo, 10);
  v13 = (const void *)v14(0, v15);
  sub_271980(v4, v13, 6661u);
  for ( i = 0; i < 0x1A05; ++i )
  {
    v22 = v4[i];
    v22 = ~v22;
    v22 ^= i;
    v22 = -v22;
    v22 += 36;
    v22 ^= i;
    v22 -= 51;
    v22 ^= 0x9Du;
    v22 -= 6;
    v22 = ~v22;
    v22 += i;
    v22 = -v22;
    v22 -= 115;
    v22 ^= i;
    v22 -= 112;
    v22 = -v22;
    v22 += 106;
    v22 = ~v22;
    v22 = (8 * v22) | ((int)v22 >> 5);
    v22 += i;
    v4[i] = v22;
  }
  v12(v4, 6661, 64, v6);
  v2 = v11(0, 0, v4, v5, 0, 0, 0, 0, 0);
  v10(v2);
  system(aCls);
  sub_273980(10, 4);
  for ( j = 0; j < 20; ++j )
  {
    sub_273950(50);
    sub_271240(asc_2760E0);
  }
  for ( j = 0; j < 20; ++j )
  {
    sub_273950(50);
    sub_271240("%c", v8[j]);
  }
  for ( j = 0; j < 20; ++j )
  {
    sub_273950(50);
    sub_271240(asc_2760E8);
  }
  sub_273980(10, 10);
  sub_273980(15, 7);
  sub_271240(aEnterPassword);
  while ( v21 != 13 )
  {
    v21 = getch();
    if ( v21 != 13 && v21 != 8 )
    {
      putch(42);
      Str1[v18++] = v21;
    }
  }
  Str1[v18] = 0;
  if ( !strcmp(Str1, Str2) )
  {
    sub_273980(15, 9);
    sub_271240(aPasswordMatch);
    sub_273980(17, 10);
    sub_271240(aPressAnyKeyToC);
    getch();
    return ((int (*)(void))sub_2736A0)();
  }
  else
  {
    sub_273980(15, 16);
    sub_271240(aWarningIncorre);
    getch();
```

The interesting part here is that the malware is loading some bytes from a resource file named “AIEUCIZEO”, which are encrypted. We know this because decryption is happening right after in a for loop.
Then, the “v12” call simply loads these bytes as a DLL.
Finally, a call to “v11” happens, which is relevant as we’ll see later.

We can clearly find the (encrypted) resource being loaded by the malware by inspecting all resources in Resource Hacker:

<img width="288" height="279" alt="image" src="https://github.com/user-attachments/assets/f53ddec1-5b42-4421-b4a7-990bb6175a1e" />

Now we can try to reconstruct the same identical DLL by performing the encryption that the malware does.

We can create a python script that loads the IEUCIZEO resource (now copied into a .bin file as a dump), and then do the same steps that the malware does to decrypt it:

#### Code 3
```python
from pathlib import Path

def rol8(x, n):
    x &= 0xFF
    return (( (x << n) & 0xFF) | (x >> (8 - n))) & 0xFF

def forward_transform(data):
    data = bytearray(data)
    n = len(data)
    for i in range(n):
        v = data[i] & 0xFF
        v = (~v) & 0xFF
        v ^= (i & 0xFF)
        v = (-v) & 0xFF
        v = (v + 36) & 0xFF
        v ^= (i & 0xFF)
        v = (v - 51) & 0xFF
        v ^= 0x9D
        v = (v - 6) & 0xFF
        v = (~v) & 0xFF
        v = (v + i) & 0xFF
        v = (-v) & 0xFF
        v = (v - 115) & 0xFF
        v ^= (i & 0xFF)
        v = (v - 112) & 0xFF
        v = (-v) & 0xFF
        v = (v + 106) & 0xFF
        v = (~v) & 0xFF
        v = rol8(v, 3)
        v = (v + i) & 0xFF
        data[i] = v
    return bytes(data)

if __name__ == "__main__":
    src = Path("resource.bin").read_bytes()
    out = forward_transform(src[:6661]) 
    Path("unpacked.bin").write_bytes(out)
    print("Wrote unpacked.bin ({} bytes)".format(len(out)))
```

This generates a new .bin file that is the decrypted resource. If we open it in IDA, we find out that it only contains a few functions.

<img width="253" height="285" alt="image" src="https://github.com/user-attachments/assets/34f09238-7677-4f15-b1eb-6260f100d1bf" />

#### Code 4
```cpp
void __stdcall sub_113F(_BYTE *finalBuffer, _BYTE *keyBuffer, unsigned int keySize)
{
  char v3[512]; // [esp+0h] [ebp-214h]
  int v4; // [esp+200h] [ebp-14h]
  int j; // [esp+204h] [ebp-10h]
  int v6; // [esp+208h] [ebp-Ch]
  char v7; // [esp+20Fh] [ebp-5h]
  int i; // [esp+210h] [ebp-4h]

  v6 = 0;
  v4 = 0;
  for ( i = 0; i < 256; ++i )
  {
    v3[i + 256] = i;
    v3[i] = keyBuffer[i % keySize];
  }
  for ( i = 0; i < 256; ++i )
  {
    v6 = ((unsigned __int8)v3[i] + v6 + (unsigned __int8)v3[i + 256]) % 256;
    v7 = v3[v6 + 256];
    v3[v6 + 256] = v3[i + 256];
    v3[i + 256] = v7;
  }
  v6 = 0;
  for ( j = 0; j < 106496; ++j )
  {
    i = (i + 1) % 256;
    v6 = (v6 + (unsigned __int8)v3[i + 256]) % 256;
    v7 = v3[v6 + 256];
    v3[v6 + 256] = v3[i + 256];
    v3[i + 256] = v7;
    v4 = ((unsigned __int8)v3[v6 + 256] + (unsigned __int8)v3[i + 256]) % 256;
    finalBuffer[j] ^= keyBuffer[j % keySize];
    finalBuffer[j] ^= v3[v4 + 256];
  }
}
```

This function seems to be taking some bytes and decrypting them. 

Said bytes are of course encrypted as the last for loop is literally just decrypting them through a secret key.

After checking this function carefully, I actually realized that Detect It Easy said the original .exe had a strange overlay section. So through DiE, we can just dump that overlay section into a .bin file:

<img width="201" height="171" alt="image" src="https://github.com/user-attachments/assets/fef1de02-4e0f-4f5e-be37-d59d2d0cc9c4" />

The for loop in **Code 3** is clearly iterating over the bytes of this overlay!


### What we know so far
1. The initial .exe is doing some benign-looking procedures.
2. It also loads an encrypted resource file (AIEUCIZEO) and decrypts it.
3. The decrypted resource file is loaded as a DLL. 
4. This DLL contains a function that decrypts the original exe’s overlay section bytes.
5. The overlay section may just be the DLL where the malware actually operates

Now we clearly want to try to reproduce the decryption routine of Code 3. We have the overlay section bytes, but since they’re encrypted, we need to find out where the key is passed to this function (and where this function of this resource is called from within the original .exe).
In Code 2 we found out a possibly interesting function call (the one in blue):

`v2 = v11(0, 0, v4, v5, 0, 0, 0, 0, 0);`

This might be relevant because v4 contains the decrypted bytes of the resource. So we can just set a breakpoint there and see what happens while debugging the .exe.


#### Not completed 
