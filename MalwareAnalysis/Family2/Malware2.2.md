Analysis of malware 2.2  – SHA256: 6ff2bdc1f84168996dc5e78e976f7ea1a8db3727d051d9a76aefb401db0bae52

# Assumptions / Notes found with DIE (Detect It Easy)
- 1.1 DiE detects a packer heuristically. The packer is not known 
- 1.2 DiE also detects Anti-debugging
- 1.3 Environment: .NET, VB.NET → managed executable → CLR (Common Language Runtime) [confirmed in Static Analysis]
- Architecture: x32
→ We already see that this is identical to Malware 2.1.

# Static analysis with ILSpy & Dynamic analysis with DnSpy
We find out that the code for the main executable is the same code of Malware 2.1, just with different names.

The only important distinction is that this.IsSingleInstance is false by default, while on the previous malware it was true by default.

This means that at runtime, Malware 2.2 takes a different code path.

#### Code 1
```csharp
[SecuritySafeCritical]
[MethodImpl(MethodImplOptions.NoInlining)]
public void Run(string[] commandLine) {
  base.InternalCommandLine = new ReadOnlyCollection < string > (commandLine);
  if (!this.IsSingleInstance) {
    this.DoApplicationModel();
    return;
  }
  string applicationInstanceID = this.GetApplicationInstanceID(Assembly.GetCallingAssembly());
  this.m_MemoryMappedID = applicationInstanceID + "Map";
  string name = applicationInstanceID + "Event";
  string text = applicationInstanceID + "Event2";
  this.m_StartNextInstanceCallback = new SendOrPostCallback(this.OnStartupNextInstanceMarshallingAdaptor);
  new SecurityPermission(SecurityPermissionFlag.ControlPrincipal).Assert();
  string name2 = WindowsIdentity.GetCurrent().Name;
  bool flag = Operators.CompareString(name2, "", false) != 0;
  CodeAccessPermission.RevertAssert();
  bool flag2;
  if (flag) {
    EventWaitHandleAccessRule rule = new EventWaitHandleAccessRule(name2, EventWaitHandleRights.FullControl, AccessControlType.Allow);
    EventWaitHandleSecurity eventWaitHandleSecurity = new EventWaitHandleSecurity();
    new SecurityPermission(SecurityPermissionFlag.ControlPrincipal).Assert();
    eventWaitHandleSecurity.AddAccessRule(rule);
    CodeAccessPermission.RevertAssert();
    this.m_FirstInstanceSemaphore = new EventWaitHandle(false, EventResetMode.ManualReset, name, ref flag2, eventWaitHandleSecurity);
    bool initialState = false;
    EventResetMode mode = EventResetMode.AutoReset;
    string name3 = text;
    bool flag3 = false;
    this.m_MessageRecievedSemaphore = new EventWaitHandle(initialState, mode, name3, ref flag3, eventWaitHandleSecurity);
  } else {
    this.m_FirstInstanceSemaphore = new EventWaitHandle(false, EventResetMode.ManualReset, name, ref flag2);
    this.m_MessageRecievedSemaphore = new EventWaitHandle(false, EventResetMode.AutoReset, text);
  }
  if (flag2) {
    try {
      TcpServerChannel tcpServerChannel = (TcpServerChannel) this.RegisterChannel(WindowsFormsApplicationBase.ChannelType.Server, flag);
      MarshalByRefObject obj = new WindowsFormsApplicationBase.RemoteCommunicator(this, this.m_MessageRecievedSemaphore);
      string text2 = applicationInstanceID + ".rem";
      new SecurityPermission(SecurityPermissionFlag.RemotingConfiguration).Assert();
      RemotingServices.Marshal(obj, text2);
      CodeAccessPermission.RevertAssert();
      string url = tcpServerChannel.GetUrlsForUri(text2)[0];
      this.WriteUrlToMemoryMappedFile(url);
      this.m_FirstInstanceSemaphore.Set();
      this.DoApplicationModel();
      return;
    } finally {
      if (this.m_MessageRecievedSemaphore != null) {
        this.m_MessageRecievedSemaphore.Close();
      }
      if (this.m_FirstInstanceSemaphore != null) {
        this.m_FirstInstanceSemaphore.Close();
      }
      if (this.m_FirstInstanceMemoryMappedFileHandle != null && !this.m_FirstInstanceMemoryMappedFileHandle.IsInvalid) {
        this.m_FirstInstanceMemoryMappedFileHandle.Close();
      }
    }
  }
  if (!this.m_FirstInstanceSemaphore.WaitOne(2500, false)) {
    throw new CantStartSingleInstanceException();
  }
  this.RegisterChannel(WindowsFormsApplicationBase.ChannelType.Client, flag);
  string text3 = this.ReadUrlFromMemoryMappedFile();
  if (text3 == null) {
    throw new CantStartSingleInstanceException();
  }
  WindowsFormsApplicationBase.RemoteCommunicator remoteCommunicator = (WindowsFormsApplicationBase.RemoteCommunicator) RemotingServices.Connect(typeof (WindowsFormsApplicationBase.RemoteCommunicator), text3);
  PermissionSet permissionSet = new PermissionSet(PermissionState.None);
  permissionSet.AddPermission(new SecurityPermission(SecurityPermissionFlag.UnmanagedCode | SecurityPermissionFlag.SerializationFormatter | SecurityPermissionFlag.ControlPrincipal));
  permissionSet.AddPermission(new DnsPermission(PermissionState.Unrestricted));
  permissionSet.AddPermission(new SocketPermission(NetworkAccess.Connect, TransportType.Tcp, "127.0.0.1", -1));
  permissionSet.AddPermission(new EnvironmentPermission(EnvironmentPermissionAccess.Read, "USERNAME"));
  permissionSet.Assert();
  remoteCommunicator.RunNextInstance(base.CommandLineArgs);
  PermissionSet.RevertAssert();
  if (!this.m_MessageRecievedSemaphore.WaitOne(2500, false)) {
    throw new CantStartSingleInstanceException();
  }
}
```

The path taken by malware 2.1 is this one at the beginning of **Code 1**:
```csharp
 if (!this.IsSingleInstance) {
    this.DoApplicationModel();
    return;
  }
```
...While malware 2.2 takes the other path.

Note that in both these paths, the end result is that this.DoApplicationModel() is called, which is the relevant part that leads to the real malware code.

The this.DoApplicationModel() is identical in both Malware 2.1 and 2.2 exes, and is:
#### Code 2
```csharp
private void DoApplicationModel()
{
  StartupEventArgs eventArgs = new StartupEventArgs(base.CommandLineArgs);
  if (!Debugger.IsAttached)
  {
    try
    {
        if (this.OnInitialize(base.CommandLineArgs) && this.OnStartup(eventArgs))
        {
            this.OnRun();
            this.OnShutdown();
        }
        return;
    }
```

And at runtime, both exes take the same path and proceed to “this.OnRun()”, which is again identical in both cases:
#### Code 3
```csharp
[SecuritySafeCritical]
[EditorBrowsable(EditorBrowsableState.Advanced)]
protected virtual void OnRun()
{
  if (this.MainForm == null)
  {
      this.OnCreateMainForm();
      if (this.MainForm == null)
      {
          throw new NoStartupFormException();
      }
      this.MainForm.Load += this.MainFormLoadingDone;
  }
```

As we saw in ANALYSIS 2.1, the code leads up to a class that loads another DLL. Here’s comparison.
### Malware 2.1 – First DLL load mechanism
```csharp
public UCOMITypeComp()
{
  this.PictureBox3 = new ExtendedNormalizationForms(this.UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU(NetCodeGroup.UrlIdentityPermission));
  this.InitializeComponent();
}


public ExtendedNormalizationForms(byte[] CustomConstantAttribute)
{
  this.WeakReference(CustomConstantAttribute);
}

// Token: 0x06000035 RID: 53 RVA: 0x000031D4 File Offset: 0x000013D4
public object WeakReference(byte[] ApplicationIdentity)
{
  Assembly assembly = Assembly.Load(ApplicationIdentity);
  Type type = assembly.GetTypes()[10];
  MethodInfo o = Type.GetType("System.Activator").GetMethods()[2];
  LateBinding.LateCall(o, null, "Invoke", new object[]
  {
      null,
      new object[]
      {
          type,
          new object[]
          {
              StrongNameMembershipCondition.ReadOnlyList,
              StrongNameMembershipCondition.PropagationFlags,
              "PowerPoint_Tools"
          }
      }
  }, null, null);
  return 23;
}
```

### Malware 2.2 – First DLL load mechanism
```csharp
 public Home()
  {
      base.Load += this.Home_Load;
      this.Gdi = new LoaderInformation(Conversions.ToString(this.Observed(Deformatter.اسدفناهژحفبناهحسفبففا)));
      this.InitializeComponent();
  }


public object SafeFileMappingHandle(byte[] ApproximateSize)
{
  Activator.CreateInstance(((Assembly)typeof(Assembly).InvokeMember("Load", BindingFlags.InvokeMethod, null, null, new object[]
  {
      ApproximateSize
  })).GetTypes()[8], new object[]
  {
      IChannelInfo.ReflectedType,
      IChannelInfo.HResult,
      "TCMS"
  });
  return 1000;
}
```

→ Both have the same code, but Malware 2.2 is less obfuscated.


## Malware 2.1 and 2.2 first DLL comparison (DLL Loader, see ANALYSIS 2.1)
- They both have the same packer
- They use obfuscation and encryption

No differences here either. After we unpack both to see the clear code, we find out that they’re loading a second DLL, as shown in ANALYSIS 2.1.

### Malware 2.1 first DLL loading part (= part that loads the second DLL)
```csharp
public static Bitmap RV(string string_0, string string_1) {
  ResourceManager resourceManager = new ResourceManager(string_1 + ".Resources", Assembly.GetEntryAssembly());
          return (Bitmap)resourceManager.GetObject(string_0);
```

### Malware 2.2 first DLL loading part (= part that loads the second DLL)
```csharp
public static Bitmap xyz(string string_0, string string_1)   {
  ResourceManager resourceManager = new ResourceManager(string_1 + ".Resources", Assembly.GetEntryAssembly());
          return (Bitmap)resourceManager.GetObject(string_0);
```

Identical code, just naming (due to obfuscation randomizing names) changes.
Both these first DLLs use stenography to load a 2nd DLL at runtime.


## Malware 2.1 and 2.2 –  2nd DLL comparison 
Through Detect It Easy we find out that both are packed with the same packer, obfuscated, and have string encryption.
So we unpack both as we did in ANALYSIS 2.1 and see whether they differ.

<img width="733" height="317" alt="image" src="https://github.com/user-attachments/assets/996a1b21-f830-476a-9f40-7f7d8d6f87de" />

→ Once again, zero differences. 

## Malware 2.1 and 2.2 – Actual Malware (C++) Exe Comparision
We found out in ANALYSIS 2.1 that the final loaded application is persistent in the OS; it’s written in C++ and contains the actual malware code.

We can’t compare the whole .exe, but with HxD (or any other capable software) we can compare the bytes of both exes.
- Through Detect It Easy we find out that both aren’t packed and were written with C++.
- Both file sizes match.
- The whole binary is identical, except for exactly 86 bytes.

<img width="690" height="131" alt="image" src="https://github.com/user-attachments/assets/ac00cd08-0cf5-4e65-96ae-6a0691a60e57" />

The picture shows what bytes differ. If we check the offsets on IDA Pro, we find out some data that is apparently never accessed (at least IDA can’t find any accesses statically). So for now it remains unknown what these bytes mean.


# Conclusions
Malware 2.2 and malware 2.1 are essentially the same with different obfuscation. However, the malware's logic remains unchanged.


