## Malware 3.1 compared to Malware 3.3
SHA256 for 3.1: b8b13abc5509d3b633788d94d80cd0e345d1b6dc3dae97cc4d8a181ee7e11a90

SHA256 for 3.3: 4970ac5fb8c1f5bbdd14796ac30deeea7d867e09ee0e1e404919263f4346afd5

We can see that both Malware are marked as `trojan.sinowal`, so similarly to Malware 3.2, Malware 3.1 might be almost identical to Malware 3.3.

The first thing we note when disassembling Malware 3.3 on IDA pro is that IDA fails to decompile it, so we can't just blindly compare the pseudocode as we did for Malware 3.3 vs Malware 3.2.

If we remember from Malware 3.3 though, its embedded payload had a fixed size that was a constant:
```cpp
sub_406690(&v26[payloadsize], v23, payloadSize);
```
In case of Malware 3.3, `payloadSize` has a value of `0x3E00`. We can use this value and see whether it exists in Malware 3.1.
To do so, we can use IDA: search => sequence of bytes => 0x3E00.

Apparently that constant exists in Malware 3.1 too:
```cpp
.data:00408428 dword_408428 dd 3E00h  
```

We can now try to set a hardware breakpoint on it for both Read and Writes, then run Malware 3.1 until it's hopefully hit. And indeed, it gets hit.
To dump the embedded payload, this is the information we needed/used while analyzing Malware 3.3:
```cpp
stubSize
buffer 
payloadStart
payloadEnd
```

In malware 3.3, `stubSize` was calculated as a difference of virtual addresses (VAs):
```cpp
payloadsize = (char *)sub_40267A - (char *)sub_4022C0;
```
which in assembly is:
```cpp
mov     eax, offset sub_40267A
sub     eax, offset sub_4022C0
push    eax
pop     [ebp+payloadsize]
```

Also, `buffer` was allocated with `VirtualAlloc` right after the `payloadSize` was calculated:
```cpp
payloadsize = (char *)sub_40267A - (char *)sub_4022C0;
v26 = (char *)VirtualAlloc(0, payloadSize + (char *)sub_40267A - (char *)sub_4022C0, 4096, 4);
```
Which in assembly is just a call to a function pointer, that just calls VirtualAlloc internally.

`payloadSize` and `buffer`'s address (obtained after VirtualAlloc returns and puts the buffer's address in the `EAX` register) is all we need, because with these two we can calculate `payloadStart` and `payloadEnd`.

We already have put a hardware breakpoint on what we assume to be `stubSize` (the one that has data `0x3E00`. So next we need to find the VAs substraction (a `sub` in asm); if we find that, we should see a call to `VirtualAlloc` some instructions later.
<img width="563" height="186" alt="image" src="https://github.com/user-attachments/assets/ef1d0306-20d0-4741-bec5-a330b6f1012b" />
This is where the breakpoint hits.

To retrieve what we think is stubSize, we can just look at the at the EDX register; while to get the address of buffer, we can look at the EAX register after the VirtualAlloc function executes (function return values are stored in EAX).
We can confirm that the call is an actual call to `VirtualAlloc` by just stepping inside of it.

This is the values that I found - note that the base address will differ on each program execution (since it's allocated at runtime).
```cpp
stubSize = 0x00000327
buffer = 0x00030000
payloadStart = buffer[stubSize] = 0x00000327 + 0x00030000 = 0x30327
payloadEnd = buffer[stubSize] + payloadSize = 0x30327 + 0x3E00 - 1 = 00034126
```

Let's now dump the region within [payloadStart, payloadEnd] as we did for Malware 3.3, and then load the generated dump in IDA.
It works: the dump of Malware 3.1's payload has an entry point and its entry point is identical to what we found for Malware 3.3!

### Comparing the payloads: Malware 3.1 vs Malware 3.3
<img width="1411" height="706" alt="image" src="https://github.com/user-attachments/assets/3ba365ff-6f79-4b31-abd6-860046803bc0" />

<img width="1379" height="273" alt="image" src="https://github.com/user-attachments/assets/abfdc99c-07cc-4b44-81b2-4af176c305b5" />

<img width="1664" height="679" alt="image" src="https://github.com/user-attachments/assets/a7c7b3cd-8eaa-42d4-9a78-c849fb0b1833" />

<img width="1340" height="569" alt="image" src="https://github.com/user-attachments/assets/cc42ad73-21d8-4001-8b40-aebcde0a3bdf" />

<img width="1677" height="687" alt="image" src="https://github.com/user-attachments/assets/d3d7edae-3572-44d6-bf08-d3753d892591" />

<img width="1659" height="695" alt="image" src="https://github.com/user-attachments/assets/8600a157-7ad4-4db3-ab0e-d0673b2d9272" />


### What differs
Once again, the only relevant thing that differs is the C2 server's address. In the case of Malware 3.1, we can find it through the debugger and it is `hwergkjgg3jhgj.com` which, similar to the other two C2 servers, is offline.





