# Analysis of malware 3.3  
SHA256: 4970ac5fb8c1f5bbdd14796ac30deeea7d867e09ee0e1e404919263f4346afd5

## Assumptions / Notes found with DIE (Detect It Easy)
- DiE detects no packer
- Environment: ASMx86 
- Architecture: x32

## Static and Dynamic analysis
Let's first quickly analyze the decompiled entry point in IDA.
#### Entry point
```cpp
int __stdcall start(int a1, int a2, int a3)
{
  if ( !dword_40C2A0 )
  {
    dword_40C2A0 = 1;
    sub_406480();
  }
  return sub_402244(a1, a2, a3);
}
```
```cpp
HANDLE sub_406480()
{
  HANDLE result; // eax
  unsigned int v1; // [esp+3C9h] [ebp-8Bh]
  char v2[112]; // [esp+3CDh] [ebp-87h] BYREF

  v1 = 0;
  strcpy(
    v2,
    "nidaght nidaght nidaght nidaght nidaght nidaght nidaghtnidaght nidaght nidaght nidaght nidaght nidaght nidaght");
  result = CreateFileA("?fn?", 2u, 2u, 0, 3u, 0x80u, 0);
  while ( v1 < 0xA )
  {
    SetEndOfFile((HANDLE)0xFF800E96);
    result = (HANDLE)CreateTapePartition((HANDLE)0xFFFFFFFF, 0, 0, 0);
    ++v1;
  }
  return result;
}
```
The first function (`sub_406480`) doesn't seem to do anything useful and the assembly seems to confirm this.
`dword_40C2A0` is initialized to 1 when the program first executes but we're not yet sure if this is relevant yet.
Next we have a call to `sub_402244(a1, a2, a3);`, which is just
#### Code 2
```cpp
int __stdcall sub_4015F3(int a1, int a2, int a3, int a4)
{
  int v5; // eax
  char v7[4]; // [esp+Dh] [ebp-8Bh] BYREF
  int v8; // [esp+11h] [ebp-87h]
  int (__cdecl *v9)(int, char *); // [esp+15h] [ebp-83h] BYREF
  char v10[15]; // [esp+19h] [ebp-7Fh] BYREF
  int v11; // [esp+28h] [ebp-70h]
  void (__cdecl *v12)(char *, int, int, int *); // [esp+2Ch] [ebp-6Ch]
  int (__cdecl *v13)(_DWORD, int, int, int); // [esp+30h] [ebp-68h]
  int v14; // [esp+34h] [ebp-64h] BYREF
  int (__cdecl *v15)(char *); // [esp+38h] [ebp-60h] BYREF
  int v16; // [esp+3Ch] [ebp-5Ch]
  int v17; // [esp+40h] [ebp-58h] BYREF
  _DWORD *v18; // [esp+44h] [ebp-54h] BYREF
  unsigned int i; // [esp+48h] [ebp-50h]
  __int16 v20; // [esp+4Ch] [ebp-4Ch]
  char v21[13]; // [esp+4Eh] [ebp-4Ah] BYREF
  char v22[13]; // [esp+5Bh] [ebp-3Dh] BYREF
  int v23; // [esp+68h] [ebp-30h] BYREF
  int v24; // [esp+6Ch] [ebp-2Ch] BYREF
  int v25; // [esp+70h] [ebp-28h]
  char *v26; // [esp+74h] [ebp-24h]
  int v27; // [esp+78h] [ebp-20h] BYREF
  char v28[12]; // [esp+7Ch] [ebp-1Ch] BYREF
  char v29[16]; // [esp+88h] [ebp-10h] BYREF

  v10[0] = -19;
  v10[1] = 0;
  v10[2] = 9;
  v10[3] = 11;
  v10[4] = 12;
  v10[5] = -8;
  v10[6] = 3;
  v10[7] = -25;
  v10[8] = 9;
  v10[9] = 6;
  v10[10] = 11;
  v10[11] = -4;
  v10[12] = -6;
  v10[13] = 11;
  v10[14] = 0;
  v28[0] = -19;
  v28[1] = 0;
  v28[2] = 9;
  v28[3] = 11;
  v28[4] = 12;
  v28[5] = -8;
  v28[6] = 3;
  v28[7] = -35;
  v28[8] = 9;
  v28[9] = -4;
  v28[10] = -4;
  v28[11] = 0;
  v22[0] = -19;
  v22[1] = 0;
  v22[2] = 9;
  v22[3] = 11;
  v22[4] = 12;
  v22[5] = -8;
  v22[6] = 3;
  v22[7] = -40;
  v22[8] = 3;
  v22[9] = 3;
  v22[10] = 6;
  v22[11] = -6;
  v22[12] = 0;
  v29[0] = -20;
  v29[1] = 5;
  v29[2] = 4;
  v29[3] = -8;
  v29[4] = 7;
  v29[5] = -19;
  v29[6] = 0;
  v29[7] = -4;
  v29[8] = 14;
  v29[9] = -26;
  v29[10] = -3;
  v29[11] = -35;
  v29[12] = 0;
  v29[13] = 3;
  v29[14] = -4;
  v29[15] = 0;
  v21[0] = 2;
  v21[1] = -4;
  v21[2] = 9;
  v21[3] = 5;
  v21[4] = -4;
  v21[5] = 3;
  v21[6] = -54;
  v21[7] = -55;
  v21[8] = -59;
  v21[9] = -5;
  v21[10] = 3;
  v21[11] = 3;
  v21[12] = 0;
  v25 = -1;
  if ( dword_40C2B8 )
  {
    v25 = dword_40C2B8(dword_40C2B4, a2, a3);
    if ( !a2 )
    {
      dword_40C2AC(dword_40C2B4, dword_40C2B0, 0x10000);
      sub_401E3C(dword_40C2A4, dword_40C2B4, dword_40C2A8);
    }
    return v25;
  }
  else
  {
    if ( !sub_406550(&unk_40905C, dword_409058, 0, &v14) )
    {
      v27 = sub_402C80(v14 + 124);
      if ( v27 )
      {
        sub_406690(v27, &unk_409000, 92);
        if ( !sub_406550(&unk_40905C, dword_409058, v27 - 39 + 131, &v14)
          && (v23 = sub_402A20(v27)) != 0
          && (v23 = sub_402B6F(v23)) != 0 )
        {
          sub_402CC3(&v27);
          dword_40C2A4 = (int)NtCurrentPeb();
          if ( !sub_401EB5(dword_40C2A4, &v9, &v15) )
          {
            sub_401DBD(v28, 11, 105);
            sub_401DBD(v10, 14, 105);
            sub_401DBD(v22, 12, 105);
            sub_401DBD(v29, 15, 105);
            sub_401DBD(v21, 12, 105);
            v5 = v15(v21);
            v16 = v5;
            if ( v5 )
            {
              dword_40C2AC = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))v9(v16, v28);
              v12 = (void (__cdecl *)(char *, int, int, int *))v9(v16, v10);
              v13 = (int (__cdecl *)(_DWORD, int, int, int))v9(v16, v22);
              v8 = v9(v16, v29);
              for ( i = (unsigned int)sub_4015F3 & 0xFFFFF000; ; i -= 4096 )
              {
                if ( *(_WORD *)i == 23117 )
                {
                  v14 = *(unsigned __int16 *)(i + *(_DWORD *)(i + 60));
                  if ( (unsigned __int8)v14 == 80 )
                    break;
                }
              }
              if ( (unsigned __int8)sub_402680(i, &v24, 0, 0) )
              {
                v20 = *(_WORD *)(v24 + 18);
                if ( (v20 & 0x2000) != 0 )
                {
                  v18 = (_DWORD *)sub_402C80(0x1Cu);
                  if ( v18 )
                  {
                    v18[2] = v9;
                    v18[3] = v15;
                    v18[5] = v13;
                    v18[6] = dword_40C2AC;
                    v18[4] = v12;
                    v18[1] = v23;
                    if ( (unsigned __int8)sub_402680(v23, 0, &v17, 0) )
                    {
                      dword_40C2B0 = *(_DWORD *)(v17 + 56);
                      dword_40C2B4 = v13(0, dword_40C2B0, 4096, 64);
                      if ( dword_40C2B4 )
                      {
                        dword_40C2A8 = i;
                        *v18 = dword_40C2B4;
                        dword_40C2B8 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))(*(_DWORD *)(v17 + 16) + dword_40C2B4);
                        sub_401E3C(dword_40C2A4, i, dword_40C2B4);
                        v25 = sub_40100F(v18);
                        sub_402CC3(&v23);
                        sub_402CC3(&v18);
                      }
                      else
                      {
                        sub_402CC3(&v18);
                        sub_402CC3(&v23);
                      }
                    }
                    else
                    {
                      sub_402CC3(&v18);
                      sub_402CC3(&v23);
                    }
                  }
                }
                else if ( sub_401322(v23, i, v15, v9) )
                {
                  v11 = (char *)sub_40267A - (char *)sub_4022C0;
                  v26 = (char *)v13(0, dword_409048 + (char *)sub_40267A - (char *)sub_4022C0, 4096, 4);
                  if ( v26 )
                  {
                    sub_406690(v26, sub_4022C0, v11);
                    sub_406690(&v26[v11], v23, dword_409048);
                    sub_402CC3(&v23);
                    if ( (unsigned __int8)sub_402680(i, 0, &v17, 0) && (unsigned __int8)sub_402680(&v26[v11], 0, v7, 0) )
                    {
                      v12(v26, dword_409048 + v11, 64, &v14);
                      ((void (__cdecl *)(char *, unsigned int, int (__cdecl *)(_DWORD, _DWORD, _DWORD), void (__cdecl *)(char *, int, int, int *), int (__cdecl *)(_DWORD, int, int, int), int, char *, int))v26)(
                        &v26[v11],
                        i,
                        dword_40C2AC,
                        v12,
                        v13,
                        v8,
                        v26,
                        a4);
                    }
                  }
                  else
                  {
                    sub_402CC3(&v23);
                  }
                }
                else
                {
                  sub_402CC3(&v23);
                }
              }
            }
          }
        }
        else
        {
          sub_402CC3(&v27);
        }
      }
    }
    return v25;
  }
}
```

The first goal here is to understand what this function does in general, so we will analyze each part.
The first branch seems to be irrelevant since by debugging we note that it isn't entered. We will try to analyze the parts of the malware that are actually used, 
and while doing this we'll also rename variables and functions to make the pseudocode clearer.
#### Code 2.5 
```cpp
else
{
  if ( !sub_406550(&unk_40905C, dword_409058, 0, &v14) )
  {
    v27 = sub_402C80(v14 + 124);
    if ( v27 )
    { // ... rest
```
Through the debugger, we see that all these branches are entered. So let's see what the first `sub_406550` does. (Note that `sub_406690` is called from `sub_406550`):
#### Code 3
```cpp
int __cdecl sub_406690(int a1, int a2, int a3)
{
  int result; // eax
  unsigned int v4; // [esp+1BCh] [ebp-4h]

  v4 = 0;
  result = 255 * a3;
  if ( a2 && a1 )
  {
    while ( v4 < 255 * a3 )
    {
      *(_BYTE *)(v4 / 0xFF + a1) = *(_BYTE *)(v4 / 0xFF + a2);
      result = v4 + 255;
      v4 += 255;
    }
  }
  return result;
}

int __cdecl sub_406550(_DWORD *a1, int a2, int a3, unsigned int *a4)
{
  int v5; // [esp+0h] [ebp-10h]
  _DWORD *v6; // [esp+4h] [ebp-Ch]
  unsigned int v7; // [esp+8h] [ebp-8h]
  unsigned int v8; // [esp+Ch] [ebp-4h]

  v6 = a1;
  v8 = 0;
  v5 = 0;
  if ( !a1 || !a2 || !a4 )
    return -1;
  v7 = *a4;
  if ( a3 )
  {
    while ( 1 )
    {
      if ( v5 + *v6 > v7 )
        return -2;
      if ( (char *)v6 + *v6 > (char *)a1 + a2 )
        return -1;
      sub_406690(v5 + a3, v6 + 2, *v6);
      if ( !v6[1] )
        break;
      v5 += *v6;
      v6 = (_DWORD *)((char *)v6 + v6[1]);
    }
    return 0;
  }
  else
  {
    while ( 1 )
    {
      v8 += *v6;
      if ( v6 > (_DWORD *)((char *)a1 + a2) )
        return -1;
      if ( !v6[1] )
        break;
      v6 = (_DWORD *)((char *)v6 + v6[1]);
    }
    *a4 = v8;
    return 0;
  }
}
```
We first analyze the `sub_406690` function since it's called within `sub_406550`, and it may help us uncover what's happening in the latter.
Clearly this line: `*(_BYTE *)(v4 / 0xFF + a1) = *(_BYTE *)(v4 / 0xFF + a2);` already tells us that `a1` and `a2` (the function parameters) are buffers, and it's copying the contents from `a2` to `a1`.
The loop uses this condition: `while ( v4 < 255 * a3 )`, which tells us that `a3` is a size.

If we rename the variables and change their types (for example, the buffer types can be changed to `char*`), we get:
#### Code 4
```cpp
int __cdecl memcopy(char *dest, char *src, int size)
{
  int result; // eax
  unsigned int idx; // [esp+1BCh] [ebp-4h]

  idx = 0;
  totalElementsMultiply255 = 255 * size;
  if ( src && dest )
  {
    while ( idx < 255 * size )
    {
      dest[idx / 255] = src[idx / 255];
      totalElementsMultiply255 = idx + 255;
      idx += 255;
    }
  }
  return totalElementsMultiply255;
}
```
This seems to just be a normal memcpy with some obfuscation. Infact, `255` is mostly irrelevant. For some reason, this function returns the total `elements * 25`, which is just `size * 255`.

We can now analyze the caller (`sub_406550`). There's two branches, and either is taken depending on the `a3` parameter, which in this case is known to be 0. The first branch is:
#### Code 5
```cpp
v6 = a1;
v8 = 0;
v5 = 0;
if ( !a1 || !a2 || !a4 )
  return -1;
v7 = *(_DWORD *)a4;
if ( a3 )
{
  while ( 1 )
  {
    if ( v5 + *(_DWORD *)v6 > v7 )
      return -2;
    if ( &v6[*(_DWORD *)v6] > &a1[a2] )
      return -1;
    memcopy(&a3[v5], v6 + 8, *(_DWORD *)v6);
    if ( !*((_DWORD *)v6 + 1) )
      break;
    v5 += *(_DWORD *)v6;
    v6 += *((_DWORD *)v6 + 1);
  }
  return 0;
}
```
Note that here, I changed the types of `v6`, `a4`, `a3` and `a1` to `char*` since they seem to be buffers. `v6` is a copy of `a1` and `v4` seems to just contain a 4 byte value.
We know that `v7` is a copy of the value contained in `a4` too.

The first thing we note is that `a3` wasn't a flag as we initially thought: it seems to just be a buffer, and if it's null (0 in our case), then the `else` branch is taken.

Thanks to the first comparision we note that `a4` just holds a value similar to a size or capacity. It also seems that `v6` (ie. `a1` buffer) is a structure, and its first 4 bytes (`DWORD`) may be a size.
This line `v6 += *((_DWORD *)v6 + 1);` seems to move the buffer to an offset. So we assume that the second element of the struture may be an offset (a 4 byte DWORD).
Next, `memcopy(&a3[v5], v6 + 8, *(_DWORD *)v6);` seems to just be copying bytes from `v6 + 8` into our `a3` buffer. Here we can confirm that the first member of our structure is a size.
And we can assume that `v6 + 8` is our third data member, which is a payload.

Let's rename the variables, after which the function should become much more understandable:
#### Code 6 (function from Code 5 made nicer)
```cpp
int __cdecl sub_406550(char *input_buffer, int input_buffer_size, char *output_buffer, char *capacity_buffer)
{
  int offset; // [esp+0h] [ebp-10h]
  char *input_buffer_copy; // [esp+4h] [ebp-Ch]
  unsigned int capacity; // [esp+8h] [ebp-8h]
  int total_size; // [esp+Ch] [ebp-4h]

  input_buffer_copy = input_buffer;
  total_size = 0;
  offset = 0;
  if ( !input_buffer || !input_buffer_size || !capacity_buffer )
    return -1;
  capacity = *(_DWORD *)capacity_buffer;
  if ( output_buffer )
  {
    while ( 1 )
    {
      if ( offset + *(_DWORD *)input_buffer_copy > capacity )
        return -2;
      if ( &input_buffer_copy[*(_DWORD *)input_buffer_copy] > &input_buffer[input_buffer_size] )
        return -1;
      memcopy(&output_buffer[offset], input_buffer_copy + 8, *(_DWORD *)input_buffer_copy);
      if ( !*((_DWORD *)input_buffer_copy + 1) )
        break;
      offset += *(_DWORD *)input_buffer_copy;
      input_buffer_copy += *((_DWORD *)input_buffer_copy + 1);
    }
    return 0;
  }
  else
  {
    while ( 1 )
    {
      total_size += *(_DWORD *)input_buffer_copy;
      if ( input_buffer_copy > &input_buffer[input_buffer_size] )
        return -1;
      if ( !*((_DWORD *)input_buffer_copy + 1) )
        break;
      input_buffer_copy += *((_DWORD *)input_buffer_copy + 1); // offset to the next entry
    }
    *(_DWORD *)capacity_buffer = total_size;
    return 0;
  }
}
```
We already found out that the data inside the buffers have this structure layout:
#### Code 7 - buffer entries structure
```cpp
struct Entry {
  std::uint32_t payloadSize;
  std::uint32_t nextEntryOffset;
  char* payload;
```
And of course, we know that the buffers have multiple such entries. For example, `input_buffer` may contain `[entry1, entry2, ..., entry n]`.

The `else` branch, taken if the `output_buffer` is null:
```cpp
else
{
  while ( 1 )
  {
    total_size += *(_DWORD *)input_buffer_copy;
    if ( input_buffer_copy > &input_buffer[input_buffer_size] )
      return -1;
    if ( !*((_DWORD *)input_buffer_copy + 1) )
      break;
    input_buffer_copy += *((_DWORD *)input_buffer_copy + 1); // offset to the next entry
  }
  *(_DWORD *)capacity_buffer = total_size;
  return 0;
}
```
simply iterates the `input_buffer`, and sums the sizes of each entry's `payload`s. Then stores the total size inside a `capacity_buffer` passed by the caller.

So this function simply:

If the output buffer is not null:
- Copies the each entry payload from an input buffer to an output buffer. The input buffer contains multiple entries and each entry is a struct `Entry`.
  The output buffer contains each payload sequentially in memory. (so basically `[[sz1, offset1, payload1][sz2,offset2,payload2]]` will become `[payload1, payload2]`

Otherwise:
- Calculates the total size (ie. the sum of all entries' sizes) from the input buffer and stores it in the capacity buffer.

We can rename it to something like "CopyAndDestructureOrGetTotalSize". Now we can get back to **code 2.5** and rename what we found so far:
```cpp
else
{
  if ( !CopyAndDestructureOrGetTotalSize(global_input_buffer, global_input_size, 0, (char *)&capacity_buffer) )
  {
    tempBuffer = (char *)HeapAllocFn(capacity_buffer + 124);
    if ( tempBuffer )
    {
```
Note that I renamed the second function to `HeapAllocFn` (easily understandable by checking the 5-liner function), and of course what it returns is allocated memory.
Now, for some reason the program is allocating the total `global_input_buffer`'s size + 124. This may be a header size but we don't know yet.


Let's proceed with the next part of the main function that we're analyzing, specifically:
#### Code 8
```cpp
memcopy(tempBuffer, byte_409000, 92);
if ( !CopyAndDestructureOrGetTotalSize(
        global_input_buffer,
        global_input_size,
        tempBuffer + 92,
        (char *)&capacity_buffer)
  && (v23 = (char *)sub_402A20(tempBuffer)) != 0
  && (v23 = (char *)sub_402B6F(v23)) != 0 )
{
  sub_402CC3(&tempBuffer);
  dword_40C2A4 = (int)NtCurrentPeb();
  if ( !sub_401EB5(dword_40C2A4, &v9, &v15) )
  ```
The first line and the `!CopyAndDestructureOrGetTotalSize` function call should be self explainatory since we already analyzed them.
So far, `tempBuffer` contains data as follows: `[92 bytes from byte_409000] [capacity bytes from global_input_buffer] [32 uninitialized bytes]`. 
The last 32 bytes are `124 - 92`; as we recall the program allocated `capacity + 124` bytes above.

Let's now analyze `sub_402A20`:
#### Code 9
```cpp
int __cdecl sub_402A20(int a1)
{
  char v2[16]; // [esp+4h] [ebp-4Ch] BYREF
  unsigned int v3; // [esp+14h] [ebp-3Ch]
  char v4[16]; // [esp+18h] [ebp-38h] BYREF
  int v5; // [esp+28h] [ebp-28h] BYREF
  int v6; // [esp+2Ch] [ebp-24h]
  int v7; // [esp+30h] [ebp-20h]
  int v8; // [esp+34h] [ebp-1Ch]
  int i; // [esp+38h] [ebp-18h]
  char v10[16]; // [esp+3Ch] [ebp-14h] BYREF
  unsigned int j; // [esp+4Ch] [ebp-4h]

  v5 = *(_DWORD *)(a1 + 36);
  v6 = *(_DWORD *)(a1 + 40);
  v7 = *(_DWORD *)(a1 + 44);
  v8 = *(_DWORD *)(a1 + 48);
  for ( i = 0; i != -1; ++i )
  {
    memcopy(v4, (char *)(a1 + 92), 16);
    v5 = *(_DWORD *)(a1 + 36);
    v6 = *(_DWORD *)(a1 + 40);
    v7 = *(_DWORD *)(a1 + 44);
    v8 = *(_DWORD *)(a1 + 48);
    sub_406DCB(v10, i, a1 + 56, 3, sub_406DB0);
    sub_406F12(v4, v10);
    sub_4069F5(v2, v4, 16);
    if ( !sub_406767(&v5, v2, 16) )
    {
      v3 = *(_DWORD *)(a1 + 80);
      for ( j = 0; j < v3; j += 8 )
        sub_406905(j + a1 + 92, v10);
      return a1;
    }
  }
  return a1;
}
```
If we further look into some functions called here, we can assume that this is a decryption routine:
```cpp
int __cdecl sub_406DCB(_DWORD *a1, int a2, __int64 *a3, unsigned int a4, void (__cdecl *a5)(int))
{
  int result; // eax
  unsigned int i; // [esp-14h] [ebp-18h]
  int v7; // [esp-Ch] [ebp-10h]
  int v8; // [esp-8h] [ebp-Ch]
  int v9; // [esp-4h] [ebp-8h]
  int v10; // [esp+Ch] [ebp+8h]

  sub_407280(a2, 1);
  for ( i = 0; i < a4; ++i )
  {
    v9 = *(_DWORD *)a3 ^ sub_40785B();
    v8 = *((_DWORD *)a3 + 1) ^ sub_40785B();
    v7 = (HIWORD(*((_DWORD *)a3 + 1)) | ((unsigned __int16)*(_DWORD *)a3 << 16)) ^ sub_40785B();
    v10 = (v7 * (v8 + v9)) ^ (((*a3 >> 16) ^ sub_40785B()) - v7 * (v8 + v9));
    a5(1);
    sub_407280(v10, 1);
  }
  *a1 = sub_40785B();
  a1[1] = sub_40785B();
  a1[2] = sub_40785B();
  result = sub_40785B();
  a1[3] = result;
  return result;
}
```

My current assumption is that the bytes taken from the global `input_buffer` and `tempBuffer` are an encrypted payload that is going to be decrypted in this function.
For now we will skip the decryption entirely (we assume that our assumptions are correct too), since we're interested in finding the malware's API, and we can hopefully use debuggers to find the encrypted payload at runtime.
If we proceed with our assumption, we can rename the function to something like `getDecrypted`.
For the sake of simplicity we'll also (at least for now) skip analyzing `sub_402B6F` since it's a really long and seemingly complicated function, and may not be needed to find where the malware sets up its APIs.

Finally, we notice this assignment: `dword_40C2A4 = (int)NtCurrentPeb();` [ #### Note1 ]
Specifically, `NtCurrentPeb` is a Windows API function that returns a pointer to the PEB (Process Environment Block) of the current process (the program that we're analyzing).
The PEB is a data structure that has info of the current process, such as image base address, process heap, loaded module lists, etc; each process has its own associated PEB.
We're not yet sure why this is needed at this point, but we'll rename the variable to reflect this.

Next we have another function call, whose return value is checked: `if ( !sub_401EB5(currentPleb, &v9, &v15) )` - Note that v9 and v15 weren't yet used.
#### Code 10
```cpp
int __cdecl sub_401EB5(int a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4; // [esp+7h] [ebp-4Dh]
  int v5; // [esp+Bh] [ebp-49h]
  __int16 v6[9]; // [esp+Fh] [ebp-45h] BYREF
  int v7; // [esp+21h] [ebp-33h]
  char v9[15]; // [esp+29h] [ebp-2Bh] BYREF
  _DWORD *v10; // [esp+38h] [ebp-1Ch]
  int v11; // [esp+3Ch] [ebp-18h]
  char v12[13]; // [esp+40h] [ebp-14h] BYREF
  _DWORD *v13; // [esp+4Dh] [ebp-7h]

  v10 = 0;
  v13 = 0;
  v6[0] = -30;
  v6[1] = -4;
  v6[2] = 9;
  v6[3] = 5;
  v6[4] = -4;
  v6[5] = 3;
  v6[6] = -54;
  v6[7] = -55;
  v6[8] = 0;
  v12[0] = -29;
  v12[1] = 6;
  v12[2] = -8;
  v12[3] = -5;
  v12[4] = -29;
  v12[5] = 0;
  v12[6] = -7;
  v12[7] = 9;
  v12[8] = -8;
  v12[9] = 9;
  v12[10] = 16;
  v12[11] = -40;
  v12[12] = 0;
  v9[0] = -34;
  v9[1] = -4;
  v9[2] = 11;
  v9[3] = -25;
  v9[4] = 9;
  v9[5] = 6;
  v9[6] = -6;
  v9[7] = -40;
  v9[8] = -5;
  v9[9] = -5;
  v9[10] = 9;
  v9[11] = -4;
  v9[12] = 10;
  v9[13] = 10;
  v9[14] = 0;
  v5 = 0;
  v7 = 0;
  sub_4020FA(v6, 8, 105);
  sub_401DBD(v9, 14, 105);
  sub_401DBD(v12, 12, 105);
  v13 = (_DWORD *)(*(_DWORD *)(a1 + 12) + 12);
  v4 = (_DWORD *)*v13;
  while ( 1 )
  {
    v10 = v4;
    v11 = v4[12];
    if ( !sub_402177(v11, v6) )
      break;
    v4 = (_DWORD *)*v4;
    if ( v4 == v13 )
      goto LABEL_6;
  }
  v11 = v10[6];
  v7 = sub_402883(v11, v9);
  if ( v7 )
  {
    v7 += v10[6];
    v5 = sub_402883(v10[6], v12);
    if ( v5 )
      v5 += v10[6];
  }
LABEL_6:
  if ( !v5 || !v7 )
    return -1;
  *a3 = v5;
  *a2 = v7;
  return 0;
}
```
Here, the first called function is `sub_4020FA(v6, 8, 105);`. The following snippet shows one function called within it (1), and then `sub_4020FA(v6, 8, 105);` (2):
#### Code 11
```cpp
// (0) - function called by sub_4020FA
unsigned int __cdecl sub_40672A(int a1, char a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int i; // [esp+8h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a3 )
      break;
    *(_BYTE *)(i + a1) = a2;
  }
  return result;
}

// (1)
unsigned int __cdecl sub_4020FA(int buffer, unsigned int a2, unsigned __int8 a3)
{
  unsigned int result; // eax
  char v4[8]; // [esp+4h] [ebp-Ch] BYREF
  unsigned int v5; // [esp+Ch] [ebp-4h]

  v5 = 0;
  result = sub_40672A((int)v4, 0, 6u);
  if ( a3 )
  {
    while ( 1 )
    {
      result = v5;
      if ( v5 >= a2 )
        break;
      *(_WORD *)(buffer + 2 * v5++) += a3;
    }
  }
  return result;
}
```
Note that (0) is basically `memset` - which is used to fill the buffer with a specified value (`a2`).

On the other hand, it's easy to see that (1) simply adds `a3` to each element in the buffer, and the returned value `result` is identical to `a2`, the buffer's size.
Let's rename the functions and variables to see clearly what's going on:
#### Code 12 - Renamed functions from Code 11 (and simplified)
```cpp
void __cdecl addValueToBuffer(char *buffer, unsigned int bufferSize, unsigned __int8 valueToAdd)
{
  char v3[8]; // [esp+4h] [ebp-Ch] BYREF
  unsigned int v4; // [esp+Ch] [ebp-4h]

  v4 = 0;
  memsetFn(v3, 0, 6u);
  if ( valueToAdd )
  {
    while ( v4 < bufferSize )
      *(_WORD *)&buffer[2 * v4++] += valueToAdd;
  }
}
```

Let's get back to **Code 10**. Why are we adding `105` to our buffers?
The reason is simple: the buffers contain some strings, and this is one way to not hardcode them in the program - this makes it harder for whoever analyzes the program to see plain text strings.
Malware often does this to hide whatever it's trying to do.

Now, to find the actual strings, all we need is to add `105` to each value and convert to ASCII; but in reality we don't need to do this since we can just debug the program and see the final strings at runtime.
By doing so, we know that in **Code 10**:
```cpp
sub_4020FA(v6, 8, 105);
sub_401DBD(v9, 14, 105);
sub_401DBD(v12, 12, 105);
```
`v6` is "Kernel32", `v9` is "GetProcAddress" and `v12` is "LoadLibraryA".

After the function calls in **Code 10** we have the following assignments:
```cpp
v13 = (_DWORD *)(*(_DWORD *)(currentPleb + 12) + 12);
v4 = (_DWORD *)*v13;
```
(Note that I renamed `a1` to `currentPleb`, we know this thanks to **Note 1** above.)
Let's first check the PEB structure from Microsoft:
#### Code 13 - Windows PEB (Process Environment Block) Structure
```cpp
typedef struct _PEB {
  BYTE                          Reserved1[2];       // offset 0
  BYTE                          BeingDebugged;      // offset 2
  BYTE                          Reserved2[1];       // Offset 3
  PVOID                         Reserved3[2];       // Offset 4
  PPEB_LDR_DATA                 Ldr;                // Offset 12 (assuming sizeof(PVOID) == 4 in x32)
  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;  // Offset 16 (assuming sizeof(void*) == 4 in x32)
  PVOID                         Reserved4[3];       // Offset 20 (assuming sizeof(void*) == 4 in x32)
  PVOID                         AtlThunkSListPtr;   // Offset 32
  PVOID                         Reserved5;          // Offset 36
  ULONG                         Reserved6;          // Offset 40
  PVOID                         Reserved7;          // Offset 44
  ULONG                         Reserved8;          // Offset 48
  ULONG                         AtlThunkSListPtr32; // Offset 52
  PVOID                         Reserved9[45];
  BYTE                          Reserved10[96];
  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
  BYTE                          Reserved11[128];
  PVOID                         Reserved12[1];
  ULONG                         SessionId;
} PEB, *PPEB;
```
IDA currently uses `int` for `currentPleb`. Let's change the type to `char*` instead so it's easier to reason about. The new assignment is:
```cpp
v13 = (_DWORD *)(*((_DWORD *)currentPleb + 3) + 12);
v4 = (_DWORD *)*v13;
```
First: `((_DWORD *)currentPleb + 3)` is just `currentPleb + 12`, which is then dereferenced. If the look in the above PEB structure, what we just dereferenced is `Ldr` at offset 12.

From the Microsoft docs, PPEB_LDR_DATA is a pointer to this structure:
```cpp
typedef struct _PEB_LDR_DATA {
  BYTE       Reserved1[8];
  PVOID      Reserved2[3];
  LIST_ENTRY InMemoryOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;
```
But after digging more into this structure, apparently on Windows x32 the structure is defined as
```cpp
0x000 Length           : Uint4B
0x004 Initialized      : UChar
0x008 SsHandle         : Ptr32 Void
0x00c InLoadOrderModuleList : _LIST_ENTRY
0x014 InMemoryOrderModuleList : _LIST_ENTRY
0x01c InInitializationOrderModuleList : _LIST_ENTRY
0x024 EntryInProgress  : Ptr32 Void
0x028 ShutdownInProgress : UChar
0x02c ShutdownThreadId : Ptr32 Void
```
The program is accessing Ldr, specifically `Ldr + 12`. My assumption is that `Ldr + 12` for our program is just `InLoadOrderModuleList` - if we use the first structure then it falls into Reserved2, which makes little sense.
(Note that these structures are internal windows structures and as the Microsoft docs say, they can change).

The `InLoadOrderModuleList` (aka `Ldr + 12`) has type `LIST_ENTRY`, which is defined as
```cpp
typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;
```

If the assumptions are correct, then the first assignment that we're analyzing end up being:
```cpp
listEntryFlinkPtr = (_DWORD *)(*((_DWORD *)currentPleb + 3) + 12);
```
And the second assignment ends up being a pointer to the first module, since `InMemoryOrderModuleList` contains the loaded modules for the process:
```cpp
modulePointer = (_DWORD *)*FlinkPtr;
```

Let's proceed with the next part of **Code 10**:
```cpp
while ( 1 )
{
  v10 = modulePointer;
  v11 = modulePointer[12];
  if ( !sub_402177(v11, (int)Kernel32String) )
    break;
  modulePointer = (_DWORD *)*modulePointer;
  if ( modulePointer == FlinkPtr )
    goto LABEL_6;
}
```
If we look at the structure for `LDR_DATA_TABLE_ENTRY` (which is the type used by `modulePointer`) at https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntldr/ldr_data_table_entry.htm, it looks like `modulePointer[12]` is just the module's name.

So this part of the function is simply comparing that string to "Kernel32" to check if the current module is the Kernel32 module, and if so, it exists the loop. Otherwise it keeps checking the next modules, until the Kernel32 module is found, or modulePointer is the original FlinkPtr (= the head) - in which case the Kernel32 module wasn't found (ie. it's not loaded) and the function returns.

We can rewrite the above function as:
```cpp
while ( 1 )
{
  lastVisitedModule = modulePointer;
  moduleInfo = modulePointer[12]; // moduleName
  if ( !areStringsEqual(moduleName, (int)Kernel32String) )
    break;
  modulePointer = (_DWORD *)*modulePointer;
  if ( modulePointer == FlinkPtr )
    goto LABEL_6;
}
```
Let's proceed with the analysis of **Code 10**:
```cpp
moduleInfo = lastVisitedModule[6]; // lastVisitedModule[6] = ModuleBase (=DllBase), and LastVisitedModule is "Kernel32"
v7 = sub_402883(moduleInfo, GetProcAddressString);
if ( v7 )
{
  v7 += lastVisitedModule[6];
  v5 = sub_402883(lastVisitedModule[6], LoadLibraryAString);
  if ( v5 )
    v5 += lastVisitedModule[6];
}
```
At this point, `lastVisitedModule` must be Kernel32 - otherwise we would've reached `goto LABEL_6` which just returns from the function.
`lastVisitedModule[6]` appears to be `PVOID DllBase` if we follow the structure in the link before.

`sub_402883` seems to just be an implementation of `GetProcessAddr` to slow down the analysis of the malware. So, the first call (whose result is assigned to v7) seems to be getting the RVA of GetProcAddress from the Kernel32 module. We assume it is a RVA, because right after we can see `v7 += lastVisitedModule[6]`, and `lastVisitedModule[6]` is the module's base address - this is adding the module's base address to the relative virtual address of GetProcAddress, thus `v7` after the if statement contains the actual virtual address of `GetProcAddressr`.

Of course the lines right after this are doing the same: `v5` ends up being the virtual address of `LoadLibraryA` from the `Kernel32` module.
Finally, at the end of **Code 10**, we can see that both the Kernel32's `GetProcAddress` and `LoadLibraryA` virtual addresses are stored inside the function arguments `a2` and `a3`.

We can now rewrite **Code 10** with better variable and function names:
#### Code 14
```cpp
void __cdecl Retrieve_GetProcAddr_LoadLibrary_FromKernel32(
        char *currentPleb,
        _DWORD *GetProcAddress_VA,
        int *LoadLibraryA_VA)
{
  _DWORD *modulePointer; // [esp+7h] [ebp-4Dh]
  int LoadLibraryA_VirtualAddress; // [esp+Bh] [ebp-49h]
  __int16 Kernel32String[9]; // [esp+Fh] [ebp-45h] BYREF
  int GetProcAddress_VirtualAddress; // [esp+21h] [ebp-33h]
  unsigned __int8 GetProcAddressString[15]; // [esp+29h] [ebp-2Bh] BYREF
  _DWORD *lastVisitedModule; // [esp+38h] [ebp-1Ch]
  char *moduleInfo; // [esp+3Ch] [ebp-18h]
  unsigned __int8 LoadLibraryAString[13]; // [esp+40h] [ebp-14h] BYREF
  _DWORD *FlinkPtr; // [esp+4Dh] [ebp-7h]

  lastVisitedModule = 0;
  FlinkPtr = 0;
  Kernel32String[0] = -30;
  Kernel32String[1] = -4;
  Kernel32String[2] = 9;
  Kernel32String[3] = 5;
  Kernel32String[4] = -4;
  Kernel32String[5] = 3;
  Kernel32String[6] = -54;
  Kernel32String[7] = -55;
  Kernel32String[8] = 0;
  LoadLibraryAString[0] = -29;
  LoadLibraryAString[1] = 6;
  LoadLibraryAString[2] = -8;
  LoadLibraryAString[3] = -5;
  LoadLibraryAString[4] = -29;
  LoadLibraryAString[5] = 0;
  LoadLibraryAString[6] = -7;
  LoadLibraryAString[7] = 9;
  LoadLibraryAString[8] = -8;
  LoadLibraryAString[9] = 9;
  LoadLibraryAString[10] = 16;
  LoadLibraryAString[11] = -40;
  LoadLibraryAString[12] = 0;
  GetProcAddressString[0] = -34;
  GetProcAddressString[1] = -4;
  GetProcAddressString[2] = 11;
  GetProcAddressString[3] = -25;
  GetProcAddressString[4] = 9;
  GetProcAddressString[5] = 6;
  GetProcAddressString[6] = -6;
  GetProcAddressString[7] = -40;
  GetProcAddressString[8] = -5;
  GetProcAddressString[9] = -5;
  GetProcAddressString[10] = 9;
  GetProcAddressString[11] = -4;
  GetProcAddressString[12] = 10;
  GetProcAddressString[13] = 10;
  GetProcAddressString[14] = 0;
  LoadLibraryA_VirtualAddress = 0;
  GetProcAddress_VirtualAddress = 0;
  addValueToBuffer((char *)Kernel32String, 8u, 0x69u);
  addValueToBuffer2((int)GetProcAddressString, 0xEu, 105);
  addValueToBuffer2((int)LoadLibraryAString, 0xCu, 105);
  FlinkPtr = (_DWORD *)(*((_DWORD *)currentPleb + 3) + 12);
  modulePointer = (_DWORD *)*FlinkPtr;
  while ( 1 )
  {
    lastVisitedModule = modulePointer;
    moduleInfo = (char *)modulePointer[12];
    if ( !areStringsEqual((int)moduleInfo, (int)Kernel32String) )
      break;
    modulePointer = (_DWORD *)*modulePointer;
    if ( modulePointer == FlinkPtr )
      goto LABEL_6;
  }
  moduleInfo = (char *)lastVisitedModule[6];    // lastVisitedModule here is Kernel32
  GetProcAddress_VirtualAddress = GetProcAddressImpl(moduleInfo, GetProcAddressString);
  if ( GetProcAddress_VirtualAddress )
  {
    GetProcAddress_VirtualAddress += lastVisitedModule[6];
    LoadLibraryA_VirtualAddress = GetProcAddressImpl((char *)lastVisitedModule[6], LoadLibraryAString);
    if ( LoadLibraryA_VirtualAddress )
      LoadLibraryA_VirtualAddress += lastVisitedModule[6];
  }
LABEL_6:
  if ( LoadLibraryA_VirtualAddress )
  {
    if ( GetProcAddress_VirtualAddress )
    {
      *LoadLibraryA_VA = LoadLibraryA_VirtualAddress;
      *GetProcAddress_VA = GetProcAddress_VirtualAddress;
    }
  }
}
```
We can also rewrite **Code 8** as:
```cpp
HeapFreeFn(&tempBuffer);
currentPleb = (int)NtCurrentPeb();
if ( !Retrieve_GetProcAddr_LoadLibrary_FromKernel32(currentPleb, &GetProcessAddressVA, &LoadLibraryA_VA) )
```

The next lines of the main function that we're analiyzing (from **Code 2**):
```cpp
addValueToBuffer2(v28, 11, 105);
addValueToBuffer2(v10, 14, 105);
addValueToBuffer2(v22, 12, 105);
addValueToBuffer2(v29, 15, 105);
addValueToBuffer2(v21, 12, 105);
v5 = LoadLibraryA_VA(v21);
v16 = v5;
if ( v5 )
```
We already know that `addValueToBuffer` is adding 105 to each element of arrays v28, v10, v22, v29 and v21. And as we said before, each element from each array will become an ASCII character after adding 105 to the original element - thus, v28, v10, v22, v29 and v21 are just strings. If we check their values through the debugger, we can rename the above code to:
```cpp
addValueToBuffer2(VirtualFreeStr, 11, 105);
addValueToBuffer2(VirtualProtectStr, 14, 105);
addValueToBuffer2(Kernel32dllStr, 12, 105);
addValueToBuffer2(UnmapViewOfFileStr, 15, 105);
addValueToBuffer2(VirtualAllocStr, 12, 105);
virtualAllocHandle = LoadLibraryA_VA(VirtualAllocStr);
v16 = virtualAllocHandle;
if ( virtualAllocHandle )
```

Let's analyze **Code 2** further:
```cpp
if ( virtualAllocHandle )
{
  dword_40C2AC = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))GetProcessAddressVA(v16, VirtualFreeStr);
  v12 = (void (__cdecl *)(char *, int, int, int *))GetProcessAddressVA(v16, VirtualProtectStr);
  v13 = (int (__cdecl *)(_DWORD, int, int, int))GetProcessAddressVA(v16, Kernel32dllStr);
  v8 = GetProcessAddressVA(v16, UnmapViewOfFileStr);
  ```
This does not need explanations and can be rewritten directly as:
```cpp
 if ( virtualAllocHandle )
{
  VirtualFree = (BOOL (__stdcall *)(LPVOID, SIZE_T, DWORD))GetProcessAddressVA(
                                                             virtualAllocHandle2,
                                                             VirtualFreeStr);
  VirtualProtect = (void (__cdecl *)(char *, int, int, int *))GetProcessAddressVA(
                                                                virtualAllocHandle2,
                                                                VirtualProtectStr);
  Kernel32Dll = (int (__cdecl *)(_DWORD, SIZE_T, int, int))GetProcessAddressVA(
                                                             virtualAllocHandle2,
                                                             Kernel32DllStr);
  UnmapViewOfFile = GetProcessAddressVA(virtualAllocHandle2, UnmapViewOfFileStr);
```

Next we have:
```cpp
for ( i = (char *)((unsigned int)sub_4015F3 & 0xFFFFF000); ; i -= 4096 )
{
  if ( *(_WORD *)i == 0x5A4D )
  {
    capacity_buffer = *(unsigned __int16 *)&i[*((_DWORD *)i + 15)];
    if ( (unsigned __int8)capacity_buffer == 80 )
      break;
  }
}
```
Note that `sub_4015F3` here is just the function that we're analyzing (**Code 2**). `i` is therefore it's address.
This part of **Code 2** requires a basic understanding of virtual addresses and pages. This is a drawing I made to show its basics and what's relevant for the analysis:
<img width="1031" height="541" alt="virtualAddress" src="https://github.com/user-attachments/assets/a167a950-f33b-4444-a11f-a7dc68c58180" />

Note that the program we're analyzing statically in IDA doesn't have its own virtual address yet - what we're analyzing is the "Program" part in the picture above.

Once again we have this:
```cpp
for ( i = (char *)((unsigned int)sub_4015F3 & 0xFFFFF000); ; i -= 4096 )
```
At runtime, the function `sub_4015F3` will have its own virtual address. And if we look at the above picture agin, we now know why this assignment is using `& 0xFFFF000`: this part is just getting the **page number** (where the `sub_4015F3` function lives at runtime in the address space of the process) and setting the offset to 0.

Next, `i` is decremented by 4096 - and 4096 is usually a page's size. But why is the program taking only the page number and removing the offset of the function within it?

This can be understood by checking the next instruction:
```cpp
if ( *(_WORD *)i == 0x5A4D ) {
```
...This is just checking whether `i` contains the "MZ" signature, which marks the beginning of a PE in memory (at runtime). And here's the catch: processes are usually aligned to pages - which means that the start of a process is almost always at the start of a page. This is why the program is removing any offset of the function's VA and then decrementing `i` by `4096`: it is looking if the current page's start contains the beginning of the PE in memory - and if it does, the program just found the module base address. (The first 2 bytes of a module base for PE files is the "MZ" signature!).

If the current page's start doesn't contain the MZ signature, then `- 4096` will just check the previous page's start (since once again, we know that the offset in the current page is `0`, which is just the page's start).

Then the program does:
```cpp
capacity_buffer = *(unsigned __int16 *)&i[*((_DWORD *)i + 15)];
if ( (unsigned __int8)capacity_buffer == 80 )
  break;
```
First, `(DWORD*)i` just treats `i` as a 4 byte pointer - `i` is the start of the `DOS` header (whose first 2 bytes contain the "MZ" signature). (See here for the DOS header: https://0xrick.github.io/win-internals/pe3/)

Since `i` is now treated as a 4 byte pointer, `+15` is just `DOS header begin + 15*4 bytes`, i.e. `DOS header begin + 60 bytes`, i.e. `DOS header begin + 0x3C bytes`. This happens to be `e_lfanew` in the DOS header, which contains the offset to the PE header, where the NT headers start.

The first 2 bytes of any valid PE process in the NT headers will be "PE", i.e. 0x5045. And in the code we are checking the first byte ("P"), i.e. 80, i.e. `0x50`.
In fact this: `&i[*((_DWORD *)i + 15)];` is just moving the module base address (where the MZ signature starts) to the found offset inside `e_lfanew`, so this retrieves the start of the NT headers. 

And as we said, `if ( (unsigned __int8)capacity_buffer == 80 )` is just checking that the NT headers start with "P" - if they don't, the found process isn't a valid PE file and the program keeps searching on the next page.
