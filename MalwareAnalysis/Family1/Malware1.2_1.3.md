# Analysis of malware 1.2
SHA256: 43b94e64a93561a9b92945eb8b2f509ef6d38c1c40b878006aca1a44b7048d39

This one is pretty much identical to malware 1.1 as shown in the following comparisions.

The entry point is pretty much identical:

<img width="1576" height="879" alt="image" src="https://github.com/user-attachments/assets/e2aa5d88-6bc7-4b87-8533-406a199003fb" />

Of course, the `Arguments` class has the same layout, but different values as we'd expect - different malware will connect to different C2 servers:

<img width="1558" height="311" alt="image" src="https://github.com/user-attachments/assets/f804a4aa-fd77-49a2-b414-a5ea4f0d72c4" />

Apart from this there's no other difference in the callbacks that we analyzed in Malware 1.1.

The assumption here is that whatever flags the C2 servers send may be different between Malware 1.1 and Malware 2.1.

I suspect that this malware was sold as MaaS (= malware as a service); this would explain why the two codebases are almost identical.


# Analysis of malware 1.3
SHA256: 394acac76f4ab92fc1dca705f4423d846bbdc6f3fe2886e4fa94149bf8d229ec

This one is a bit more tricky compared to the previous 2 because 
- It is much more obfuscated, and
- It seemingly crashes on purpose, giving weird error messages when ran (even without a debugger).

For example, this is its entry point:
```csharp
[STAThread]
[STAThread]
private static int ѤѥﬤѠﬦѤﬣѠﬧѠѢѠﬥѤﬠѥѥѣѡѥﬣ\uFB29ﬠѡﬡﬠѠﬧ\uFB29ﬠ\uFB29ﬣѠﬥ\uFB29ѢﬣѥﬡﬡfZsASGtIbYEvPmVtviLOpHFZGMzk/o}^+i!Kh^DoJu;M~1c:Jl'I#(string[])
{
}
```

After various attempt trying to dump the malware at runtime (through tcpdump, megadumper, extremedumper and the likes), it seems like `hollows hunter` (https://github.com/hasherezade/hollows_hunter) does the jobs.
Apparently when the malware is ran, it spawns a custom `MSBuild.exe`, which is what I dumped to get the unobfuscated malware.


Opening the dump in DnSpy, we can now see the clear Entry Point:
```csharp
internal class Program
{
	// Token: 0x06000033 RID: 51 RVA: 0x00004047 File Offset: 0x00002447
	private static void Main(string[] args)
	{
		new EntryPoint().Execute();
	}
}
```

It turns out that even Malware 1.3 uses the same identical logic to Malware 1.1, **but** it is completely unobfuscated after taking a runtime dump!

<img width="1579" height="963" alt="image" src="https://github.com/user-attachments/assets/731ebc35-677a-4a3c-9a21-f4629e4f4a28" />

<img width="1470" height="691" alt="image" src="https://github.com/user-attachments/assets/8eeb474e-3505-44bb-bb49-759e6800b90b" />

This is what we reverse-enginereed for Malware 1.1's "Entity7", which we renamed to "UserInfo":
```chsarp
public struct UserInfo
{
    public string UserID { get; set; }
    public string Id2 { get; set; }
    public string Username { get; set; }
    public string ProductNameAndArchitecture { get; set; }
    public string InputLanguage { get; set; }
    public string VirtualDisplaySize { get; set; }
    public Entity1 FullUserInfo { get; set; } // not always used
    public string Id8 { get; set; }
    public string Id9 { get; set; }
    public string LocalZoneDisplayName { get; set; }
    public string IPv4_Address { get; set; }
    public byte[] Id12 { get; set; }
    public string Id13 { get; set; }
    public string ExecutablePath { get; set; }
    public bool isVisible { get; set; }
}
```

And this is what we see for the same class in Malware 1.3:
```csharp
public struct ScanResult
{
	public string Hardware { get; set; }
	public string ReleaseID { get; set; }
	public string MachineName { get; set; }
	public string OSVersion { get; set; }
	public string Language { get; set; }
	public string ScreenSize { get; set; }
	public ScanDetails ScanDetails { get; set; }
	public string Country { get; set; }
	public string City { get; set; }
	public string TimeZone { get; set; }
	public string IPv4 { get; set; }
	public byte[] Monitor { get; set; }
	public string ZipCode { get; set; }
	public string FileLocation { get; set; }
	public bool SeenBefore { get; set; }
}
```

...So basically, we don't even need to reverse engineer Malware 1.3. All we can do is just check whatever classes it has - these classes will have identical layouts to what we analyzed in Malware 1.1, and thus the same API.

**But** this also means that whatever we failed to find in Malware 1.1 is now easily findable. For examble, as shown in the code above, we did not find out what `Id8` or `Id9` were. Turns out that they're just Country and City!


# Conclusions
All 3 malware of the first family are pretty much identical:
- Their Client=>C2 server API is the same.
- They're all obfuscated or packed.

The main differences lie in:
- Obfuscation: Malware 1.2 is pretty much plain-text; malware 1.1 has some basic obfuscation, and malware 1.3 has a much harder obfuscation + packing. But by taking a dump, we can get the unpacked and unobfuscated .exe (by using hollow hunter).
- The C2 servers are of course different.
- Different encryption keys in the `Arguments` class, as we've seen in the pictures above.
- The C2 servers may have different flag values.

The fact that all 3 malware are almost identical leads me to believe that they were obtained from paid MaaS (Malware as a service). 

MaaS would allow a beginner attacker to create custom malware that performs the same operations in the target client (infected), 
while also allowing to customize the C2 server flags, which means that different C2 servers may steal different data even though the malware's codebase is the same.
